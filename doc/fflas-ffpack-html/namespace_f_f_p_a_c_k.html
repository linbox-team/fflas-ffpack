<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFLAS-FFPACK: FFPACK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FFLAS-FFPACK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FFPACK Namespace Reference<div class="ingroups"><a class="el" href="group__ffpack.html">FFPACK</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><b>F</b>inite <b>F</b>ield <b>PACK</b> Set of elimination based routines for dense linear algebra.  
<a href="namespace_f_f_p_a_c_k.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_f_p_a_c_k_1_1_failure.html">Failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A precondtion failed.  <a href="class_f_f_p_a_c_k_1_1_failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">node Class for the tree representation.  <a href="class_f_f_p_a_c_k_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for the <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html" title="Class for the RRRrep ( a tree of nodes )">RRRrep</a> ( a tree of nodes )  <a href="class_f_f_p_a_c_k_1_1_r_r_rrep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a213f24b93e481e4e7efd899e59a2b17e"><td class="memItemLeft" align="right" valign="top"><a id="a213f24b93e481e4e7efd899e59a2b17e" name="a213f24b93e481e4e7efd899e59a2b17e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LAPACKPerm2MathPerm</b> (size_t *MathP, const size_t *LapackP, const size_t N)</td></tr>
<tr class="memdesc:a213f24b93e481e4e7efd899e59a2b17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of a permutation from LAPACK format to Math format. <br /></td></tr>
<tr class="separator:a213f24b93e481e4e7efd899e59a2b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4320d92abd30637ce5b26c50f989b11"><td class="memItemLeft" align="right" valign="top"><a id="aa4320d92abd30637ce5b26c50f989b11" name="aa4320d92abd30637ce5b26c50f989b11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MathPerm2LAPACKPerm</b> (size_t *LapackP, const size_t *MathP, const size_t N)</td></tr>
<tr class="memdesc:aa4320d92abd30637ce5b26c50f989b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of a permutation from Maths format to LAPACK format. <br /></td></tr>
<tr class="separator:aa4320d92abd30637ce5b26c50f989b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1cddd27a131dabda817df0ec0b7177"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a1b1cddd27a131dabda817df0ec0b7177"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1b1cddd27a131dabda817df0ec0b7177">applyP</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const FFLAS::FFLAS_TRANSPOSE Trans, const size_t M, const size_t ibeg, const size_t iend, typename Field::Element_ptr A, const size_t lda, const size_t *P)</td></tr>
<tr class="memdesc:a1b1cddd27a131dabda817df0ec0b7177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in P1 as a LAPACK permutation.  <a href="namespace_f_f_p_a_c_k.html#a1b1cddd27a131dabda817df0ec0b7177">More...</a><br /></td></tr>
<tr class="separator:a1b1cddd27a131dabda817df0ec0b7177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a2e0a8fba965dfc44b5ef07ab856ed825">MonotonicApplyP</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const FFLAS::FFLAS_TRANSPOSE Trans, const size_t M, const size_t ibeg, const size_t iend, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t R)</td></tr>
<tr class="memdesc:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a R-monotonically increasing permutation P, to the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a2e0a8fba965dfc44b5ef07ab856ed825">More...</a><br /></td></tr>
<tr class="separator:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a43b157c8206491f4c4e5337a3f9423"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a0a43b157c8206491f4c4e5337a3f9423"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a0a43b157c8206491f4c4e5337a3f9423">fgetrs</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t R, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t *Q, typename Field::Element_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a0a43b157c8206491f4c4e5337a3f9423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system <img class="formulaInl" alt="$A X = B$" src="form_78.png"/> or <img class="formulaInl" alt="$X A = B$" src="form_79.png"/>.  <a href="namespace_f_f_p_a_c_k.html#a0a43b157c8206491f4c4e5337a3f9423">More...</a><br /></td></tr>
<tr class="separator:a0a43b157c8206491f4c4e5337a3f9423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a19f62816af5c3957e5d8dcd60eed1f3f">fgetrs</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t NRHS, const size_t R, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t *Q, typename Field::Element_ptr X, const size_t ldx, typename Field::ConstElement_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system A X = B or X A = B.  <a href="namespace_f_f_p_a_c_k.html#a19f62816af5c3957e5d8dcd60eed1f3f">More...</a><br /></td></tr>
<tr class="separator:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f26909f63a855dfeefee2d55dae1d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ade4f26909f63a855dfeefee2d55dae1d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ade4f26909f63a855dfeefee2d55dae1d">fgesv</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:ade4f26909f63a855dfeefee2d55dae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square system solver.  <a href="namespace_f_f_p_a_c_k.html#ade4f26909f63a855dfeefee2d55dae1d">More...</a><br /></td></tr>
<tr class="separator:ade4f26909f63a855dfeefee2d55dae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a68ff465a100ffa4c64abd6be721c3d3d">fgesv</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t NRHS, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, typename Field::ConstElement_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a68ff465a100ffa4c64abd6be721c3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangular system solver.  <a href="namespace_f_f_p_a_c_k.html#a68ff465a100ffa4c64abd6be721c3d3d">More...</a><br /></td></tr>
<tr class="separator:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae8ebbf599c6c93aa1689edd3763b1887">ftrtri</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG Diag, const size_t N, typename Field::Element_ptr A, const size_t lda, const size_t threshold=__FFLASFFPACK_FTRTRI_THRESHOLD)</td></tr>
<tr class="memdesc:ae8ebbf599c6c93aa1689edd3763b1887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a triangular matrix.  <a href="namespace_f_f_p_a_c_k.html#ae8ebbf599c6c93aa1689edd3763b1887">More...</a><br /></td></tr>
<tr class="separator:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab7c38fdc258c7071c3d4ff39ee419a9c">ftrtrm</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE side, const FFLAS::FFLAS_DIAG diag, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of two triangular matrices of opposite shape.  <a href="namespace_f_f_p_a_c_k.html#ab7c38fdc258c7071c3d4ff39ee419a9c">More...</a><br /></td></tr>
<tr class="separator:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adece02815384390d9693661abee012ed"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:adece02815384390d9693661abee012ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#adece02815384390d9693661abee012ed">ftrstr</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE side, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diagA, const FFLAS::FFLAS_DIAG diagB, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, const size_t threshold=64)</td></tr>
<tr class="memdesc:adece02815384390d9693661abee012ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular system with a triangular right hand side of the same shape.  <a href="namespace_f_f_p_a_c_k.html#adece02815384390d9693661abee012ed">More...</a><br /></td></tr>
<tr class="separator:adece02815384390d9693661abee012ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72941c6ae84659f44db2b096458bda56"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a72941c6ae84659f44db2b096458bda56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a72941c6ae84659f44db2b096458bda56">ftrssyr2k</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diagA, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, const size_t threshold=64)</td></tr>
<tr class="memdesc:a72941c6ae84659f44db2b096458bda56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular system in a symmetric sum: find B upper/lower triangular such that A^T B + B^T A = C where C is symmetric.  <a href="namespace_f_f_p_a_c_k.html#a72941c6ae84659f44db2b096458bda56">More...</a><br /></td></tr>
<tr class="separator:a72941c6ae84659f44db2b096458bda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea15a71392b8116270ba58d44f99b0a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:abea15a71392b8116270ba58d44f99b0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#abea15a71392b8116270ba58d44f99b0a">fsytrf</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO UpLo, const size_t N, typename Field::Element_ptr A, const size_t lda, const size_t threshold=__FFLASFFPACK_FSYTRF_THRESHOLD)</td></tr>
<tr class="memdesc:abea15a71392b8116270ba58d44f99b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular factorization of symmetric matrices.  <a href="namespace_f_f_p_a_c_k.html#abea15a71392b8116270ba58d44f99b0a">More...</a><br /></td></tr>
<tr class="separator:abea15a71392b8116270ba58d44f99b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03905818bbd609ea0318414856d20374"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a03905818bbd609ea0318414856d20374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a03905818bbd609ea0318414856d20374">fsytrf_nonunit</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO UpLo, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr D, const size_t incD, const size_t threshold=__FFLASFFPACK_FSYTRF_THRESHOLD)</td></tr>
<tr class="memdesc:a03905818bbd609ea0318414856d20374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular factorization of symmetric matrices.  <a href="namespace_f_f_p_a_c_k.html#a03905818bbd609ea0318414856d20374">More...</a><br /></td></tr>
<tr class="separator:a03905818bbd609ea0318414856d20374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f90809584dae59b27fec78c77e927"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a834f90809584dae59b27fec78c77e927"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a834f90809584dae59b27fec78c77e927">PLUQ</a> (const Field &amp;F, const FFLAS::FFLAS_DIAG Diag, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Q)</td></tr>
<tr class="memdesc:a834f90809584dae59b27fec78c77e927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a PLUQ factorization of the given matrix; such that A=PLUQ.  <a href="namespace_f_f_p_a_c_k.html#a834f90809584dae59b27fec78c77e927">More...</a><br /></td></tr>
<tr class="separator:a834f90809584dae59b27fec78c77e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8167a1477d10a7367cce30923281b0fe"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8167a1477d10a7367cce30923281b0fe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8167a1477d10a7367cce30923281b0fe">LUdivine</a> (const Field &amp;F, const FFLAS::FFLAS_DIAG Diag, const FFLAS::FFLAS_TRANSPOSE trans, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive, const size_t cutoff=__FFLASFFPACK_LUDIVINE_THRESHOLD)</td></tr>
<tr class="memdesc:a8167a1477d10a7367cce30923281b0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CUP or PLE factorization of the given matrix.  <a href="namespace_f_f_p_a_c_k.html#a8167a1477d10a7367cce30923281b0fe">More...</a><br /></td></tr>
<tr class="separator:a8167a1477d10a7367cce30923281b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a150d6acb28e77ec56949bf99dd8e3e73">ColumnEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a150d6acb28e77ec56949bf99dd8e3e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Column Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#a150d6acb28e77ec56949bf99dd8e3e73">More...</a><br /></td></tr>
<tr class="separator:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a8223494b06149b4db058c56b25083"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa5a8223494b06149b4db058c56b25083"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aa5a8223494b06149b4db058c56b25083">RowEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aa5a8223494b06149b4db058c56b25083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Row Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#aa5a8223494b06149b4db058c56b25083">More...</a><br /></td></tr>
<tr class="separator:aa5a8223494b06149b4db058c56b25083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a813e34d18a3de299b26bd9de2c8e4b4d">ReducedColumnEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Reduced Column Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#a813e34d18a3de299b26bd9de2c8e4b4d">More...</a><br /></td></tr>
<tr class="separator:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab9aba43cbf35752df1c5c5f24193fb2a">ReducedRowEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Reduced Row Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#ab9aba43cbf35752df1c5c5f24193fb2a">More...</a><br /></td></tr>
<tr class="separator:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62197ee1bbc40b25843361f574bf9748"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a62197ee1bbc40b25843361f574bf9748"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a62197ee1bbc40b25843361f574bf9748">Invert</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, int &amp;nullity)</td></tr>
<tr class="memdesc:a62197ee1bbc40b25843361f574bf9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix in place or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a62197ee1bbc40b25843361f574bf9748">More...</a><br /></td></tr>
<tr class="separator:a62197ee1bbc40b25843361f574bf9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4336928c74f094a5ddebcec18bb17bb5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4336928c74f094a5ddebcec18bb17bb5"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4336928c74f094a5ddebcec18bb17bb5">Invert</a> (const Field &amp;F, const size_t M, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, int &amp;nullity)</td></tr>
<tr class="memdesc:a4336928c74f094a5ddebcec18bb17bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a4336928c74f094a5ddebcec18bb17bb5">More...</a><br /></td></tr>
<tr class="separator:a4336928c74f094a5ddebcec18bb17bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681c044c0d4533c4387ef15e867fd886"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a681c044c0d4533c4387ef15e867fd886"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a681c044c0d4533c4387ef15e867fd886">Invert2</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, int &amp;nullity)</td></tr>
<tr class="memdesc:a681c044c0d4533c4387ef15e867fd886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a681c044c0d4533c4387ef15e867fd886">More...</a><br /></td></tr>
<tr class="separator:a681c044c0d4533c4387ef15e867fd886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; typename PolRing::Element &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1d3e9f9fe5ff9d62e286be6eda2b01bf">CharPoly</a> (const PolRing &amp;R, std::list&lt; typename PolRing::Element &gt; &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, typename PolRing::Domain_t::RandIter &amp;G, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a1d3e9f9fe5ff9d62e286be6eda2b01bf">More...</a><br /></td></tr>
<tr class="separator:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memTemplItemLeft" align="right" valign="top">PolRing::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#af12460cbc0f7735e5c6ac5eaba73a17b">CharPoly</a> (const PolRing &amp;R, typename PolRing::Element &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, typename PolRing::Domain_t::RandIter &amp;G, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#af12460cbc0f7735e5c6ac5eaba73a17b">More...</a><br /></td></tr>
<tr class="separator:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2bcea333b6c2732fde289f3c572c00"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:a8c2bcea333b6c2732fde289f3c572c00"><td class="memTemplItemLeft" align="right" valign="top">PolRing::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8c2bcea333b6c2732fde289f3c572c00">CharPoly</a> (const PolRing &amp;R, typename PolRing::Element &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:a8c2bcea333b6c2732fde289f3c572c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a8c2bcea333b6c2732fde289f3c572c00">More...</a><br /></td></tr>
<tr class="separator:a8c2bcea333b6c2732fde289f3c572c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225ba4356fcea2d470835ead0278237e"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial &gt; </td></tr>
<tr class="memitem:a225ba4356fcea2d470835ead0278237e"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a225ba4356fcea2d470835ead0278237e">MinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:a225ba4356fcea2d470835ead0278237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a225ba4356fcea2d470835ead0278237e">More...</a><br /></td></tr>
<tr class="separator:a225ba4356fcea2d470835ead0278237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial , class RandIter &gt; </td></tr>
<tr class="memitem:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a862701a92e6d2b12e40b5a7f6b2e06ee">MinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a862701a92e6d2b12e40b5a7f6b2e06ee">More...</a><br /></td></tr>
<tr class="separator:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial &gt; </td></tr>
<tr class="memitem:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac1eeaee05c99ce77fa38b64e8fe1fa11">MatVecMinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::ConstElement_ptr v, const size_t incv)</td></tr>
<tr class="memdesc:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A and a vector v, namely the first linear dependency relation in the Krylov basis <img class="formulaInl" alt="$(v,Av, ..., A^Nv)$" src="form_91.png"/>.  <a href="namespace_f_f_p_a_c_k.html#ac1eeaee05c99ce77fa38b64e8fe1fa11">More...</a><br /></td></tr>
<tr class="separator:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb286015f6161e817d28298ac7f02e7e"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:afb286015f6161e817d28298ac7f02e7e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#afb286015f6161e817d28298ac7f02e7e">Rank</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:afb286015f6161e817d28298ac7f02e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of the given matrix using a PLUQ factorization.  <a href="namespace_f_f_p_a_c_k.html#afb286015f6161e817d28298ac7f02e7e">More...</a><br /></td></tr>
<tr class="separator:afb286015f6161e817d28298ac7f02e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231910d94ef4832edb786ceb8574cace"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a231910d94ef4832edb786ceb8574cace"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a231910d94ef4832edb786ceb8574cace">IsSingular</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:a231910d94ef4832edb786ceb8574cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given matrix is singular.  <a href="namespace_f_f_p_a_c_k.html#a231910d94ef4832edb786ceb8574cace">More...</a><br /></td></tr>
<tr class="separator:a231910d94ef4832edb786ceb8574cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memTemplItemLeft" align="right" valign="top">Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a82f1c3a47ce5b9ee39c5ac44864add93">Det</a> (const Field &amp;F, typename Field::Element &amp;det, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P=NULL, size_t *Q=NULL)</td></tr>
<tr class="memdesc:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the given square matrix.  <a href="namespace_f_f_p_a_c_k.html#a82f1c3a47ce5b9ee39c5ac44864add93">More...</a><br /></td></tr>
<tr class="separator:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b24993d207d33830edf3286f7332631"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8b24993d207d33830edf3286f7332631"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8b24993d207d33830edf3286f7332631">Solve</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr x, const int incx, typename Field::ConstElement_ptr b, const int incb)</td></tr>
<tr class="memdesc:a8b24993d207d33830edf3286f7332631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear system AX = b using PLUQ factorization.  <a href="namespace_f_f_p_a_c_k.html#a8b24993d207d33830edf3286f7332631">More...</a><br /></td></tr>
<tr class="separator:a8b24993d207d33830edf3286f7332631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memTemplItemLeft" align="right" valign="top">*void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4f559150c4ef2579bbd9dcd0b97eef30">RandomNullSpaceVector</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t incX)</td></tr>
<tr class="memdesc:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve L X = B or X L = B in place.  <a href="namespace_f_f_p_a_c_k.html#a4f559150c4ef2579bbd9dcd0b97eef30">More...</a><br /></td></tr>
<tr class="separator:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a668c07f738a5d813fc1ff7d0b60cd4ef">NullSpaceBasis</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;NS, size_t &amp;ldn, size_t &amp;NSdim)</td></tr>
<tr class="memdesc:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a basis of the Left/Right nullspace of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a668c07f738a5d813fc1ff7d0b60cd4ef">More...</a><br /></td></tr>
<tr class="separator:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a61b01710a3a14e5ddeff63e7dde312e5">RowRankProfile</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rkprofile, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a61b01710a3a14e5ddeff63e7dde312e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#a61b01710a3a14e5ddeff63e7dde312e5">More...</a><br /></td></tr>
<tr class="separator:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad2a30cbb378686c18f8fda52a2ea692c">ColumnRankProfile</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rkprofile, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ad2a30cbb378686c18f8fda52a2ea692c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the column rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#ad2a30cbb378686c18f8fda52a2ea692c">More...</a><br /></td></tr>
<tr class="separator:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210f3ceeca532699f4567098c22e0c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a210f3ceeca532699f4567098c22e0c30">RankProfileFromLU</a> (const size_t *P, const size_t N, const size_t R, size_t *rkprofile, const FFPACK_LU_TAG LuTag)</td></tr>
<tr class="memdesc:a210f3ceeca532699f4567098c22e0c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the column/row rank profile from the permutation of an LU decomposition.  <a href="namespace_f_f_p_a_c_k.html#a210f3ceeca532699f4567098c22e0c30">More...</a><br /></td></tr>
<tr class="separator:a210f3ceeca532699f4567098c22e0c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6732312bd3b9111ed2beda4d4989407"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab6732312bd3b9111ed2beda4d4989407">LeadingSubmatrixRankProfiles</a> (const size_t M, const size_t N, const size_t R, const size_t LSm, const size_t LSn, const size_t *P, const size_t *Q, size_t *RRP, size_t *CRP)</td></tr>
<tr class="memdesc:ab6732312bd3b9111ed2beda4d4989407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the row and column rank profiles of any leading submatrix from the PLUQ decomposition.  <a href="namespace_f_f_p_a_c_k.html#ab6732312bd3b9111ed2beda4d4989407">More...</a><br /></td></tr>
<tr class="separator:ab6732312bd3b9111ed2beda4d4989407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a9101aa5d87ae4ffcacf3f5ea97fdd4df">RowRankProfileSubmatrixIndices</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rowindices, size_t *&amp;colindices, size_t &amp;R)</td></tr>
<tr class="memdesc:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">RowRankProfileSubmatrixIndices.  <a href="namespace_f_f_p_a_c_k.html#a9101aa5d87ae4ffcacf3f5ea97fdd4df">More...</a><br /></td></tr>
<tr class="separator:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a8f20a642f161be15d54e9e84a276f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad6a8f20a642f161be15d54e9e84a276f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad6a8f20a642f161be15d54e9e84a276f">ColRankProfileSubmatrixIndices</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rowindices, size_t *&amp;colindices, size_t &amp;R)</td></tr>
<tr class="memdesc:ad6a8f20a642f161be15d54e9e84a276f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the indices of the submatrix r*r X of A whose columns correspond to the column rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#ad6a8f20a642f161be15d54e9e84a276f">More...</a><br /></td></tr>
<tr class="separator:ad6a8f20a642f161be15d54e9e84a276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae44ada9ac14df2273cd42d5844b4fa4a">RowRankProfileSubmatrix</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;X, size_t &amp;R)</td></tr>
<tr class="memdesc:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the r*r submatrix X of A, by picking the row rank profile rows of A.  <a href="namespace_f_f_p_a_c_k.html#ae44ada9ac14df2273cd42d5844b4fa4a">More...</a><br /></td></tr>
<tr class="separator:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8a8befa801a6defffa9043081cb60"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa6a8a8befa801a6defffa9043081cb60"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aa6a8a8befa801a6defffa9043081cb60">ColRankProfileSubmatrix</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;X, size_t &amp;R)</td></tr>
<tr class="memdesc:aa6a8a8befa801a6defffa9043081cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <img class="formulaInl" alt="$ r\times r$" src="form_93.png"/> submatrix X of A, by picking the row rank profile rows of A.  <a href="namespace_f_f_p_a_c_k.html#aa6a8a8befa801a6defffa9043081cb60">More...</a><br /></td></tr>
<tr class="separator:aa6a8a8befa801a6defffa9043081cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00545c213322e599f00bfa88dda0b201"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a00545c213322e599f00bfa88dda0b201"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a00545c213322e599f00bfa88dda0b201">getTriangular</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false)</td></tr>
<tr class="memdesc:a00545c213322e599f00bfa88dda0b201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a triangular matrix from a compact storage A=L\U of rank R.  <a href="namespace_f_f_p_a_c_k.html#a00545c213322e599f00bfa88dda0b201">More...</a><br /></td></tr>
<tr class="separator:a00545c213322e599f00bfa88dda0b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9639c015458dc8849bc463bbcb1da1f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab9639c015458dc8849bc463bbcb1da1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab9639c015458dc8849bc463bbcb1da1f">getTriangular</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:ab9639c015458dc8849bc463bbcb1da1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U to reveal a triangular matrix of rank R.  <a href="namespace_f_f_p_a_c_k.html#ab9639c015458dc8849bc463bbcb1da1f">More...</a><br /></td></tr>
<tr class="separator:ab9639c015458dc8849bc463bbcb1da1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef728bf19985baf2a219feac8cb28929"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aef728bf19985baf2a219feac8cb28929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aef728bf19985baf2a219feac8cb28929">getEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aef728bf19985baf2a219feac8cb28929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#aef728bf19985baf2a219feac8cb28929">More...</a><br /></td></tr>
<tr class="separator:aef728bf19985baf2a219feac8cb28929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae248d48e7687959fa602ea13fdb8bf4a">getEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::Element_ptr A, const size_t lda, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ae248d48e7687959fa602ea13fdb8bf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U obtained by RowEchelonForm or ColumnEchelonForm to reveal an echelon form of rank R.  <a href="namespace_f_f_p_a_c_k.html#ae248d48e7687959fa602ea13fdb8bf4a">More...</a><br /></td></tr>
<tr class="separator:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee39112d215c8f520c8a8409dfcb82b5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aee39112d215c8f520c8a8409dfcb82b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aee39112d215c8f520c8a8409dfcb82b5">getEchelonTransform</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aee39112d215c8f520c8a8409dfcb82b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#aee39112d215c8f520c8a8409dfcb82b5">More...</a><br /></td></tr>
<tr class="separator:aee39112d215c8f520c8a8409dfcb82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae330c736c7e0c7eb585d7885bd70004b"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae330c736c7e0c7eb585d7885bd70004b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae330c736c7e0c7eb585d7885bd70004b">getReducedEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ae330c736c7e0c7eb585d7885bd70004b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true.  <a href="namespace_f_f_p_a_c_k.html#ae330c736c7e0c7eb585d7885bd70004b">More...</a><br /></td></tr>
<tr class="separator:ae330c736c7e0c7eb585d7885bd70004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab82ac3be0b0c94ca64f73e84952e9466">getReducedEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::Element_ptr A, const size_t lda, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ab82ac3be0b0c94ca64f73e84952e9466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true.  <a href="namespace_f_f_p_a_c_k.html#ab82ac3be0b0c94ca64f73e84952e9466">More...</a><br /></td></tr>
<tr class="separator:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e646e2d8b711a662e010c74ad57b82"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:af4e646e2d8b711a662e010c74ad57b82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#af4e646e2d8b711a662e010c74ad57b82">getReducedEchelonTransform</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:af4e646e2d8b711a662e010c74ad57b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#af4e646e2d8b711a662e010c74ad57b82">More...</a><br /></td></tr>
<tr class="separator:af4e646e2d8b711a662e010c74ad57b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b938a39392432499087789fd3582eac"><td class="memItemLeft" align="right" valign="top"><a id="a7b938a39392432499087789fd3582eac" name="a7b938a39392432499087789fd3582eac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PLUQtoEchelonPermutation</b> (const size_t N, const size_t R, const size_t *P, size_t *outPerm)</td></tr>
<tr class="memdesc:a7b938a39392432499087789fd3582eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routine: determines the permutation that changes a PLUQ decomposition into a echelon form revealing PLUQ decomposition. <br /></td></tr>
<tr class="separator:a7b938a39392432499087789fd3582eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3229b60de912473f3ce4cb3df8753e"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a9c3229b60de912473f3ce4cb3df8753e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a9c3229b60de912473f3ce4cb3df8753e">LTBruhatGen</a> (const Field &amp;Fi, const FFLAS::FFLAS_DIAG diag, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Q)</td></tr>
<tr class="memdesc:a9c3229b60de912473f3ce4cb3df8753e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LTBruhatGen Suppose A is Left Triangular Matrix This procedure computes the Bruhat Representation of A and return the rank of A.  <a href="namespace_f_f_p_a_c_k.html#a9c3229b60de912473f3ce4cb3df8753e">More...</a><br /></td></tr>
<tr class="separator:a9c3229b60de912473f3ce4cb3df8753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae9d34e03d5e3d7d413acd1947a821a7f">getLTBruhatGen</a> (const Field &amp;Fi, const size_t N, const size_t r, const size_t *P, const size_t *Q, typename Field::Element_ptr R, const size_t ldr)</td></tr>
<tr class="memdesc:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetLTBruhatGen This procedure Computes the Rank Revealing Matrix based on the Bruhta representation of a Matrix.  <a href="namespace_f_f_p_a_c_k.html#ae9d34e03d5e3d7d413acd1947a821a7f">More...</a><br /></td></tr>
<tr class="separator:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4970621f589c8a8c0e26dbb8a61d386f">getLTBruhatGen</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t N, const size_t r, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt)</td></tr>
<tr class="memdesc:a4970621f589c8a8c0e26dbb8a61d386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetLTBruhatGen This procedure computes the matrix L or U f the Bruhat Representation Suppose that A is the bruhat representation of a matrix.  <a href="namespace_f_f_p_a_c_k.html#a4970621f589c8a8c0e26dbb8a61d386f">More...</a><br /></td></tr>
<tr class="separator:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39434278672787e41dff88fc5977d8b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a39434278672787e41dff88fc5977d8b6">LTQSorder</a> (const size_t N, const size_t r, const size_t *P, const size_t *Q)</td></tr>
<tr class="memdesc:a39434278672787e41dff88fc5977d8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LTQSorder This procedure computes the order of quasiseparability of a matrix.  <a href="namespace_f_f_p_a_c_k.html#a39434278672787e41dff88fc5977d8b6">More...</a><br /></td></tr>
<tr class="separator:a39434278672787e41dff88fc5977d8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac4c6629de5a1a0349eac3c1d2b73f1a1">CompressToBlockBiDiagonal</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, size_t N, size_t s, size_t r, const size_t *P, const size_t *Q, typename Field::Element_ptr A, size_t lda, typename Field::Element_ptr X, size_t ldx, size_t *K, size_t *M, size_t *T)</td></tr>
<tr class="memdesc:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CompressToBlockBiDiagonal This procedure compress a compact representation of a row echelon form or column echelon form.  <a href="namespace_f_f_p_a_c_k.html#ac4c6629de5a1a0349eac3c1d2b73f1a1">More...</a><br /></td></tr>
<tr class="separator:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4354fca8409da50f288d59c69a888970"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4354fca8409da50f288d59c69a888970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4354fca8409da50f288d59c69a888970">ExpandBlockBiDiagonalToBruhat</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, size_t N, size_t s, size_t r, typename Field::Element_ptr A, size_t lda, typename Field::Element_ptr X, size_t ldx, size_t NbBlocks, size_t *K, size_t *M, size_t *T)</td></tr>
<tr class="memdesc:a4354fca8409da50f288d59c69a888970"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExpandBlockBiDiagonal This procedure expand a compact representation of a row echelon form or column echelon form.  <a href="namespace_f_f_p_a_c_k.html#a4354fca8409da50f288d59c69a888970">More...</a><br /></td></tr>
<tr class="separator:a4354fca8409da50f288d59c69a888970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1508bd2e3ea0ef3b4e9022783dc871e7">Bruhat2EchelonPermutation</a> (size_t N, size_t R, const size_t *P, const size_t *Q, size_t *M)</td></tr>
<tr class="memdesc:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bruhat2EchelonPermutation (N,R,P,Q) Compute M such that LM or MU is in echelon form where L or U are factors of the Bruhat Rpresentation.  <a href="namespace_f_f_p_a_c_k.html#a1508bd2e3ea0ef3b4e9022783dc871e7">More...</a><br /></td></tr>
<tr class="separator:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memTemplParams" colspan="2"><a id="af40ef0a04be6f8fa4d423a1d49094b07" name="af40ef0a04be6f8fa4d423a1d49094b07"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>productBruhatxTS</b> (const Field &amp;Fi, size_t N, size_t s, size_t r, const size_t *P, const size_t *Q, const typename Field::Element_ptr Xu, size_t ldu, size_t NbBlocksU, size_t *Ku, size_t *Tu, size_t *MU, const typename Field::Element_ptr Xl, size_t ldl, size_t NbBlocksL, size_t *Kl, size_t *Tl, size_t *ML, typename Field::Element_ptr B, size_t t, size_t ldb, typename Field::Element_ptr C, size_t ldc)</td></tr>
<tr class="memdesc:af40ef0a04be6f8fa4d423a1d49094b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">productBruhatxTS Comput the product between the CRE compact representation of a matrix A and B a tall matrix <br /></td></tr>
<tr class="separator:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fb5610440268a1977b4b3a2adcfc8"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a691fb5610440268a1977b4b3a2adcfc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a691fb5610440268a1977b4b3a2adcfc8">productSSSxTS</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::ConstElement_ptr P, size_t ldp, typename Field::ConstElement_ptr Q, size_t ldq, typename Field::ConstElement_ptr R, size_t ldr, typename Field::ConstElement_ptr U, size_t ldu, typename Field::ConstElement_ptr V, size_t ldv, typename Field::ConstElement_ptr W, size_t ldw, typename Field::ConstElement_ptr D, size_t ldd, size_t t, const typename Field::Element alpha, typename Field::Element_ptr B, size_t ldb, const typename Field::Element beta, typename Field::Element_ptr C, size_t ldc)</td></tr>
<tr class="memdesc:a691fb5610440268a1977b4b3a2adcfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a quasi-separable matrix A, represented by a sequentially semi-separable generator, with a dense rectangular matrix B: <img class="formulaInl" alt="$ C \gets \alpha * A \times B + beta C $" src="form_94.png"/>.  <a href="namespace_f_f_p_a_c_k.html#a691fb5610440268a1977b4b3a2adcfc8">More...</a><br /></td></tr>
<tr class="separator:a691fb5610440268a1977b4b3a2adcfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cbfc65f210580e0ef820d42774a046"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a75cbfc65f210580e0ef820d42774a046"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a75cbfc65f210580e0ef820d42774a046">SSSToDense</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::ConstElement_ptr P, size_t ldp, typename Field::ConstElement_ptr Q, size_t ldq, typename Field::ConstElement_ptr R, size_t ldr, typename Field::ConstElement_ptr U, size_t ldu, typename Field::ConstElement_ptr V, size_t ldv, typename Field::ConstElement_ptr W, size_t ldw, typename Field::ConstElement_ptr D, size_t ldd, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a75cbfc65f210580e0ef820d42774a046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a quasi-separable matrix A from its SSS generators.  <a href="namespace_f_f_p_a_c_k.html#a75cbfc65f210580e0ef820d42774a046">More...</a><br /></td></tr>
<tr class="separator:a75cbfc65f210580e0ef820d42774a046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad974b5a7591c6956046d4473a30dc"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a43ad974b5a7591c6956046d4473a30dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a43ad974b5a7591c6956046d4473a30dc">DenseToSSS</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::Element_ptr P, size_t ldp, typename Field::Element_ptr Q, size_t ldq, typename Field::Element_ptr R, size_t ldr, typename Field::Element_ptr U, size_t ldu, typename Field::Element_ptr V, size_t ldv, typename Field::Element_ptr W, size_t ldw, typename Field::Element_ptr D, size_t ldd, typename Field::ConstElement_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a43ad974b5a7591c6956046d4473a30dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SSS generators for a quasi-separable matrix A.  <a href="namespace_f_f_p_a_c_k.html#a43ad974b5a7591c6956046d4473a30dc">More...</a><br /></td></tr>
<tr class="separator:a43ad974b5a7591c6956046d4473a30dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a3cd7b5a41ec8f1e7b722b50e8a836559">LQUPtoInverseOfFullRankMinor</a> (const Field &amp;F, const size_t rank, typename Field::Element_ptr A_factors, const size_t lda, const size_t *QtPointer, typename Field::Element_ptr X, const size_t ldx)</td></tr>
<tr class="memdesc:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="mdescLeft">&#160;</td><td class="mdescRight">LQUPtoInverseOfFullRankMinor.  <a href="namespace_f_f_p_a_c_k.html#a3cd7b5a41ec8f1e7b722b50e8a836559">More...</a><br /></td></tr>
<tr class="separator:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ff1ad45afee814978cd0431442f11a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a18ff1ad45afee814978cd0431442f11a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a18ff1ad45afee814978cd0431442f11a">RandomNullSpaceVector</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t incX)</td></tr>
<tr class="memdesc:a18ff1ad45afee814978cd0431442f11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve L X = B or X L = B in place.  <a href="namespace_f_f_p_a_c_k.html#a18ff1ad45afee814978cd0431442f11a">More...</a><br /></td></tr>
<tr class="separator:a18ff1ad45afee814978cd0431442f11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c1be98d5721b477c7f9f9be95c66ce"><td class="memTemplParams" colspan="2"><a id="a45c1be98d5721b477c7f9f9be95c66ce" name="a45c1be98d5721b477c7f9f9be95c66ce"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:a45c1be98d5721b477c7f9f9be95c66ce"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>expandLCRE</b> (const Field &amp;Fi, size_t N, size_t s, size_t r, size_t *R, size_t i, typename Field::ConstElement_ptr Xu, size_t ldu, size_t NbBlocksU, const size_t *Ku, const size_t *Tuinv, typename Field::ConstElement_ptr Xl, size_t ldl, size_t NbBlocksL, const size_t *Kl, const size_t *Tlinv, typename Field::Element_ptr CRE, size_t ldcre)</td></tr>
<tr class="memdesc:a45c1be98d5721b477c7f9f9be95c66ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands an anti-diagonal block of a left triangular matrix from its compact Bruhat representation. <br /></td></tr>
<tr class="separator:a45c1be98d5721b477c7f9f9be95c66ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb90d1e5e309062288c2abd69877b58"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:adfb90d1e5e309062288c2abd69877b58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#adfb90d1e5e309062288c2abd69877b58">productBruhatxTS</a> (const Field &amp;Fi, size_t N, size_t s, size_t r, size_t t, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr Xu, size_t ldu, size_t NbBlocksU, const size_t *Ku, const size_t *Tu, const size_t *MU, typename Field::ConstElement_ptr Xl, size_t ldl, size_t NbBlocksL, const size_t *Kl, const size_t *Tl, const size_t *ML, typename Field::Element_ptr B, size_t ldb, const typename Field::Element beta, typename Field::Element_ptr D, size_t ldd)</td></tr>
<tr class="memdesc:adfb90d1e5e309062288c2abd69877b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a left-triangular quasi-separable matrix A, represented by a compact Bruhat generator, with a dense rectangular matrix B: <img class="formulaInl" alt="$ C \gets A \times B + beta C $" src="form_101.png"/>.  <a href="namespace_f_f_p_a_c_k.html#adfb90d1e5e309062288c2abd69877b58">More...</a><br /></td></tr>
<tr class="separator:adfb90d1e5e309062288c2abd69877b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94502af7c734c7855d895308d26d1493"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a94502af7c734c7855d895308d26d1493"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a94502af7c734c7855d895308d26d1493">buildMatrix</a> (const Field &amp;F, typename Field::ConstElement_ptr E, typename Field::ConstElement_ptr C, const size_t lda, const size_t *B, const size_t *T, const size_t me, const size_t mc, const size_t lambda, const size_t mu)</td></tr>
<tr class="separator:a94502af7c734c7855d895308d26d1493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f31e0a202436eda09472c4363dfb69"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad9f31e0a202436eda09472c4363dfb69"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad9f31e0a202436eda09472c4363dfb69">fsytrf_UP_RPM</a> (const Field &amp;Fi, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr Dinv, const size_t incDinv, size_t *P, size_t BCThreshold)</td></tr>
<tr class="separator:ad9f31e0a202436eda09472c4363dfb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e49bbe7a2dea84f08ae1fe0e91bcc"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a6e7e49bbe7a2dea84f08ae1fe0e91bcc"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a6e7e49bbe7a2dea84f08ae1fe0e91bcc">LUdivine</a> (const Field &amp;F, const FFLAS::FFLAS_DIAG Diag, const FFLAS::FFLAS_TRANSPOSE trans, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Q, const FFPACK::FFPACK_LU_TAG LuTag, const size_t cutoff)</td></tr>
<tr class="separator:a6e7e49bbe7a2dea84f08ae1fe0e91bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f4db92c513a15a5079ea1cfd609960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac5f4db92c513a15a5079ea1cfd609960">composePermutationsLLL</a> (size_t *P1, const size_t *P2, const size_t R, const size_t N)</td></tr>
<tr class="memdesc:ac5f4db92c513a15a5079ea1cfd609960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in P1 as a LAPACK permutation.  <a href="namespace_f_f_p_a_c_k.html#ac5f4db92c513a15a5079ea1cfd609960">More...</a><br /></td></tr>
<tr class="separator:ac5f4db92c513a15a5079ea1cfd609960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7889cb2cdf1eb12d30144155f364ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a7e7889cb2cdf1eb12d30144155f364ac">composePermutationsLLM</a> (size_t *MathP, const size_t *P1, const size_t *P2, const size_t R, const size_t N)</td></tr>
<tr class="memdesc:a7e7889cb2cdf1eb12d30144155f364ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in MathP as a MathPermutation format.  <a href="namespace_f_f_p_a_c_k.html#a7e7889cb2cdf1eb12d30144155f364ac">More...</a><br /></td></tr>
<tr class="separator:a7e7889cb2cdf1eb12d30144155f364ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a966205b9cc62fda547fd31e30da56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a73a966205b9cc62fda547fd31e30da56">composePermutationsMLM</a> (size_t *MathP1, const size_t *P2, const size_t R, const size_t N)</td></tr>
<tr class="memdesc:a73a966205b9cc62fda547fd31e30da56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes MathP1 x Diag (I_R, P2) where MathP1 is a MathPermutation and P2 a LAPACK permutation and store the result in MathP1 as a MathPermutation format.  <a href="namespace_f_f_p_a_c_k.html#a73a966205b9cc62fda547fd31e30da56">More...</a><br /></td></tr>
<tr class="separator:a73a966205b9cc62fda547fd31e30da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac202d94135e30327511e47311647f14a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ac202d94135e30327511e47311647f14a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac202d94135e30327511e47311647f14a">PLUQRRRGen_rec</a> (const Field &amp;Fi, const size_t N, const size_t s, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:ac202d94135e30327511e47311647f14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">RRR Generator recursive part.  <a href="namespace_f_f_p_a_c_k.html#ac202d94135e30327511e47311647f14a">More...</a><br /></td></tr>
<tr class="separator:ac202d94135e30327511e47311647f14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6530e127d526df2d1721475a47874eef"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a6530e127d526df2d1721475a47874eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a6530e127d526df2d1721475a47874eef">PLUQRRRGen</a> (const Field &amp;Fi, const size_t N, const size_t s, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:a6530e127d526df2d1721475a47874eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">RRR Generator API.  <a href="namespace_f_f_p_a_c_k.html#a6530e127d526df2d1721475a47874eef">More...</a><br /></td></tr>
<tr class="separator:a6530e127d526df2d1721475a47874eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf47737c405f93df531d8ca134b74354"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:abf47737c405f93df531d8ca134b74354"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#abf47737c405f93df531d8ca134b74354">RRRExpandrec</a> (const Field &amp;Fi, const <a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; &amp;nodeA, typename Field::Element_ptr B, const size_t ldb)</td></tr>
<tr class="memdesc:abf47737c405f93df531d8ca134b74354"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 4) Compute the dense matrix of RRR(A) in B recursive part  <a href="namespace_f_f_p_a_c_k.html#abf47737c405f93df531d8ca134b74354">More...</a><br /></td></tr>
<tr class="separator:abf47737c405f93df531d8ca134b74354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac8b66d78d34e86ed061c7dc54be29b"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8ac8b66d78d34e86ed061c7dc54be29b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8ac8b66d78d34e86ed061c7dc54be29b">RRRExpand</a> (const Field &amp;Fi, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;RRRA, typename Field::Element_ptr B, const size_t ldb)</td></tr>
<tr class="memdesc:a8ac8b66d78d34e86ed061c7dc54be29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 4) Compute the dense matrix of RRR(A) in B  <a href="namespace_f_f_p_a_c_k.html#a8ac8b66d78d34e86ed061c7dc54be29b">More...</a><br /></td></tr>
<tr class="separator:a8ac8b66d78d34e86ed061c7dc54be29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb26e7290ab3774a597b9560d57edf11"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aeb26e7290ab3774a597b9560d57edf11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aeb26e7290ab3774a597b9560d57edf11">RRxRR</a> (const Field &amp;Fi, size_t r_A, size_t m, size_t r_b, size_t n, size_t k, typename Field::ConstElement_ptr LA, size_t ldLA, typename Field::ConstElement_ptr UA, size_t ldUA, typename Field::ConstElement_ptr LB, size_t ldLB, typename Field::ConstElement_ptr UB, size_t ldUB)</td></tr>
<tr class="memdesc:aeb26e7290ab3774a597b9560d57edf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 5) multiplies two matrices stored as rank revealing factorization.  <a href="namespace_f_f_p_a_c_k.html#aeb26e7290ab3774a597b9560d57edf11">More...</a><br /></td></tr>
<tr class="separator:aeb26e7290ab3774a597b9560d57edf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa62160dad26925283196e9de5917abf"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aaa62160dad26925283196e9de5917abf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aaa62160dad26925283196e9de5917abf">RRaddRR</a> (const Field &amp;Fi, size_t r_A, size_t r_b, size_t m, size_t n, typename Field::ConstElement_ptr LA, size_t ldLA, typename Field::ConstElement_ptr UA, size_t ldUA, typename Field::ConstElement_ptr LB, size_t ldLB, typename Field::ConstElement_ptr UB, size_t ldUB)</td></tr>
<tr class="memdesc:aaa62160dad26925283196e9de5917abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 6) add two matrices stored as rank revealing factorization  <a href="namespace_f_f_p_a_c_k.html#aaa62160dad26925283196e9de5917abf">More...</a><br /></td></tr>
<tr class="separator:aaa62160dad26925283196e9de5917abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cec2abe2f1d191ede7ff60efe7f585"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab5cec2abe2f1d191ede7ff60efe7f585"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab5cec2abe2f1d191ede7ff60efe7f585">RRRaddRR</a> (const Field &amp;Fi, size_t s, size_t r_b, size_t n, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;A, typename Field::ConstElement_ptr LB, size_t ldLB, typename Field::ConstElement_ptr UB, size_t ldUB)</td></tr>
<tr class="memdesc:ab5cec2abe2f1d191ede7ff60efe7f585"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 7) Adds a quasiseparable matrix in RRR representation and a rank revealing factorization.  <a href="namespace_f_f_p_a_c_k.html#ab5cec2abe2f1d191ede7ff60efe7f585">More...</a><br /></td></tr>
<tr class="separator:ab5cec2abe2f1d191ede7ff60efe7f585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3056d72f6cee15adc4a15d7e388161d1"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a3056d72f6cee15adc4a15d7e388161d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a3056d72f6cee15adc4a15d7e388161d1">RRRxTSrec</a> (const Field &amp;Fi, size_t s, size_t n, size_t t, const <a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; &amp;nodeA, typename Field::ConstElement_ptr B, size_t ldB, typename Field::ConstElement_ptr C, size_t ldC)</td></tr>
<tr class="memdesc:a3056d72f6cee15adc4a15d7e388161d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 8) Multiplies a quasiseparable matric in RRR representation with a tall and skinny matrix  <a href="namespace_f_f_p_a_c_k.html#a3056d72f6cee15adc4a15d7e388161d1">More...</a><br /></td></tr>
<tr class="separator:a3056d72f6cee15adc4a15d7e388161d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e640c8922617688cb055a051e4d6951"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a1e640c8922617688cb055a051e4d6951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1e640c8922617688cb055a051e4d6951">RRRxTS</a> (const Field &amp;Fi, size_t s, size_t n, size_t t, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;A, typename Field::ConstElement_ptr B, size_t ldB, typename Field::ConstElement_ptr C, size_t ldC)</td></tr>
<tr class="memdesc:a1e640c8922617688cb055a051e4d6951"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 8) Multiplies a quasiseparable matric in RRR representation with a tall and skinny matrix  <a href="namespace_f_f_p_a_c_k.html#a1e640c8922617688cb055a051e4d6951">More...</a><br /></td></tr>
<tr class="separator:a1e640c8922617688cb055a051e4d6951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bc7eac6d6c3e1c174ebda55485868b"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad0bc7eac6d6c3e1c174ebda55485868b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad0bc7eac6d6c3e1c174ebda55485868b">RRRxRR</a> (const Field &amp;Fi, size_t s, size_t n, size_t r_b, size_t m, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;A, typename Field::ConstElement_ptr LB, size_t ldLB, typename Field::ConstElement_ptr UB, size_t ldUB, typename Field::Element_ptr LC, size_t ldLC, typename Field::Element_ptr UC, size_t ldUC)</td></tr>
<tr class="memdesc:ad0bc7eac6d6c3e1c174ebda55485868b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(algo 9) Multiplies a QS matrix in RRR representation with a rank revealing factorization Compute C = A*B  <a href="namespace_f_f_p_a_c_k.html#ad0bc7eac6d6c3e1c174ebda55485868b">More...</a><br /></td></tr>
<tr class="separator:ad0bc7eac6d6c3e1c174ebda55485868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8bc54c52fd8eaccb1e5692b5bf6fdb"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:afc8bc54c52fd8eaccb1e5692b5bf6fdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#afc8bc54c52fd8eaccb1e5692b5bf6fdb">RRRxRRR</a> (const Field &amp;Fi, size_t s, size_t t, size_t n, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;A, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;B)</td></tr>
<tr class="memdesc:afc8bc54c52fd8eaccb1e5692b5bf6fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies two QS matrices (algo 10)  <a href="namespace_f_f_p_a_c_k.html#afc8bc54c52fd8eaccb1e5692b5bf6fdb">More...</a><br /></td></tr>
<tr class="separator:afc8bc54c52fd8eaccb1e5692b5bf6fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81631373e30bf744d23506adf9f1e732"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a81631373e30bf744d23506adf9f1e732"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a81631373e30bf744d23506adf9f1e732">RRRinvert</a> (const Field &amp;Fi, const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;A)</td></tr>
<tr class="memdesc:a81631373e30bf744d23506adf9f1e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse in RRR representation.  <a href="namespace_f_f_p_a_c_k.html#a81631373e30bf744d23506adf9f1e732">More...</a><br /></td></tr>
<tr class="separator:a81631373e30bf744d23506adf9f1e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6d819cd3915b3eae46791ee3c2ba7b"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a5c6d819cd3915b3eae46791ee3c2ba7b"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a5c6d819cd3915b3eae46791ee3c2ba7b">NonZeroRandomMatrix</a> (const Field &amp;F, size_t m, size_t n, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a5c6d819cd3915b3eae46791ee3c2ba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random non-zero Matrix.  <a href="namespace_f_f_p_a_c_k.html#a5c6d819cd3915b3eae46791ee3c2ba7b">More...</a><br /></td></tr>
<tr class="separator:a5c6d819cd3915b3eae46791ee3c2ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84356fd5ca2843795970e30c7d2af66b"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a84356fd5ca2843795970e30c7d2af66b"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a84356fd5ca2843795970e30c7d2af66b">NonZeroRandomMatrix</a> (const Field &amp;F, size_t m, size_t n, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a84356fd5ca2843795970e30c7d2af66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random non-zero Matrix.  <a href="namespace_f_f_p_a_c_k.html#a84356fd5ca2843795970e30c7d2af66b">More...</a><br /></td></tr>
<tr class="separator:a84356fd5ca2843795970e30c7d2af66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584460ea638cb2942b89ef28dd58c489"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a584460ea638cb2942b89ef28dd58c489"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a584460ea638cb2942b89ef28dd58c489">RandomMatrix</a> (const Field &amp;F, size_t m, size_t n, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a584460ea638cb2942b89ef28dd58c489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix.  <a href="namespace_f_f_p_a_c_k.html#a584460ea638cb2942b89ef28dd58c489">More...</a><br /></td></tr>
<tr class="separator:a584460ea638cb2942b89ef28dd58c489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab288de7b77ff71e4d05930e27486bf52"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab288de7b77ff71e4d05930e27486bf52"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab288de7b77ff71e4d05930e27486bf52">RandomMatrix</a> (const Field &amp;F, size_t m, size_t n, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:ab288de7b77ff71e4d05930e27486bf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix.  <a href="namespace_f_f_p_a_c_k.html#ab288de7b77ff71e4d05930e27486bf52">More...</a><br /></td></tr>
<tr class="separator:ab288de7b77ff71e4d05930e27486bf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b5ff1e71e0e518f7d7a5624245501"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a040b5ff1e71e0e518f7d7a5624245501"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a040b5ff1e71e0e518f7d7a5624245501">RandomTriangularMatrix</a> (const Field &amp;F, size_t m, size_t n, const FFLAS::FFLAS_UPLO UpLo, const FFLAS::FFLAS_DIAG Diag, bool nonsingular, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a040b5ff1e71e0e518f7d7a5624245501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Triangular Matrix.  <a href="namespace_f_f_p_a_c_k.html#a040b5ff1e71e0e518f7d7a5624245501">More...</a><br /></td></tr>
<tr class="separator:a040b5ff1e71e0e518f7d7a5624245501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8389197600198a0d756662596b59268a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8389197600198a0d756662596b59268a"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8389197600198a0d756662596b59268a">RandomTriangularMatrix</a> (const Field &amp;F, size_t m, size_t n, const FFLAS::FFLAS_UPLO UpLo, const FFLAS::FFLAS_DIAG Diag, bool nonsingular, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a8389197600198a0d756662596b59268a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Triangular Matrix.  <a href="namespace_f_f_p_a_c_k.html#a8389197600198a0d756662596b59268a">More...</a><br /></td></tr>
<tr class="separator:a8389197600198a0d756662596b59268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b941fefbfda9aaf0272d5b1476da563"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a9b941fefbfda9aaf0272d5b1476da563"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a9b941fefbfda9aaf0272d5b1476da563">RandomSymmetricMatrix</a> (const Field &amp;F, size_t n, bool nonsingular, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a9b941fefbfda9aaf0272d5b1476da563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Symmetric Matrix.  <a href="namespace_f_f_p_a_c_k.html#a9b941fefbfda9aaf0272d5b1476da563">More...</a><br /></td></tr>
<tr class="separator:a9b941fefbfda9aaf0272d5b1476da563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317eca01fd2d55e857e5eeb37698eb0a"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a317eca01fd2d55e857e5eeb37698eb0a"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a317eca01fd2d55e857e5eeb37698eb0a">RandomMatrixWithRank</a> (const Field &amp;F, size_t m, size_t n, size_t r, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a317eca01fd2d55e857e5eeb37698eb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank.  <a href="namespace_f_f_p_a_c_k.html#a317eca01fd2d55e857e5eeb37698eb0a">More...</a><br /></td></tr>
<tr class="separator:a317eca01fd2d55e857e5eeb37698eb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af772df4d24c94818f611bc842e44b569"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:af772df4d24c94818f611bc842e44b569"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#af772df4d24c94818f611bc842e44b569">RandomMatrixWithRank</a> (const Field &amp;F, size_t m, size_t n, size_t r, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:af772df4d24c94818f611bc842e44b569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank.  <a href="namespace_f_f_p_a_c_k.html#af772df4d24c94818f611bc842e44b569">More...</a><br /></td></tr>
<tr class="separator:af772df4d24c94818f611bc842e44b569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f4cadf20c5e40912db77e34a65b318"><td class="memItemLeft" align="right" valign="top">size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae3f4cadf20c5e40912db77e34a65b318">RandomIndexSubset</a> (size_t N, size_t R, size_t *P)</td></tr>
<tr class="memdesc:ae3f4cadf20c5e40912db77e34a65b318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick uniformly at random a sequence of <code>R</code> distinct elements from the set <img class="formulaInl" alt="$ \{0,\dots, N-1\}$" src="form_106.png"/> using Knuth's shuffle.  <a href="namespace_f_f_p_a_c_k.html#ae3f4cadf20c5e40912db77e34a65b318">More...</a><br /></td></tr>
<tr class="separator:ae3f4cadf20c5e40912db77e34a65b318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52a08d2b41e281e34d5b41496bfddf8"><td class="memItemLeft" align="right" valign="top">size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae52a08d2b41e281e34d5b41496bfddf8">RandomPermutation</a> (size_t N, size_t *P)</td></tr>
<tr class="memdesc:ae52a08d2b41e281e34d5b41496bfddf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick uniformly at random a permutation of size <code>N</code> stored in LAPACK format using Knuth's shuffle.  <a href="namespace_f_f_p_a_c_k.html#ae52a08d2b41e281e34d5b41496bfddf8">More...</a><br /></td></tr>
<tr class="separator:ae52a08d2b41e281e34d5b41496bfddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d6ef645c3268a94d70c2e5d4f0ca8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad7d6ef645c3268a94d70c2e5d4f0ca8e">RandomRankProfileMatrix</a> (size_t M, size_t N, size_t R, size_t *rows, size_t *cols)</td></tr>
<tr class="memdesc:ad7d6ef645c3268a94d70c2e5d4f0ca8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick uniformly at random an R-subpermutation of dimension <code>M</code> x <code>N</code> : a matrix with only R non-zeros equal to one, in a random rook placement.  <a href="namespace_f_f_p_a_c_k.html#ad7d6ef645c3268a94d70c2e5d4f0ca8e">More...</a><br /></td></tr>
<tr class="separator:ad7d6ef645c3268a94d70c2e5d4f0ca8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1370fe044bc6259c148a1d9ca84cc970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1370fe044bc6259c148a1d9ca84cc970">RandomSymmetricRankProfileMatrix</a> (size_t N, size_t R, size_t *rows, size_t *cols)</td></tr>
<tr class="memdesc:a1370fe044bc6259c148a1d9ca84cc970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick uniformly at random a symmetric R-subpermutation of dimension <code>N</code> x <code>N</code> : a symmetric matrix with only R non-zeros, all equal to one, in a random rook placement.  <a href="namespace_f_f_p_a_c_k.html#a1370fe044bc6259c148a1d9ca84cc970">More...</a><br /></td></tr>
<tr class="separator:a1370fe044bc6259c148a1d9ca84cc970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff744c6fc1bf46097fed4905b407d02"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a2ff744c6fc1bf46097fed4905b407d02"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a2ff744c6fc1bf46097fed4905b407d02">RandomMatrixWithRankandRPM</a> (const Field &amp;F, size_t M, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, const size_t *RRP, const size_t *CRP, RandIter &amp;G)</td></tr>
<tr class="memdesc:a2ff744c6fc1bf46097fed4905b407d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank and rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>.  <a href="namespace_f_f_p_a_c_k.html#a2ff744c6fc1bf46097fed4905b407d02">More...</a><br /></td></tr>
<tr class="separator:a2ff744c6fc1bf46097fed4905b407d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f761ba30a690239450b7b6ede1c7e"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a323f761ba30a690239450b7b6ede1c7e"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a323f761ba30a690239450b7b6ede1c7e">RandomMatrixWithRankandRPM</a> (const Field &amp;F, size_t M, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, const size_t *RRP, const size_t *CRP)</td></tr>
<tr class="memdesc:a323f761ba30a690239450b7b6ede1c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank and rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>.  <a href="namespace_f_f_p_a_c_k.html#a323f761ba30a690239450b7b6ede1c7e">More...</a><br /></td></tr>
<tr class="separator:a323f761ba30a690239450b7b6ede1c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf60dc80006757b600bd802746ab8bb9"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:aaf60dc80006757b600bd802746ab8bb9"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aaf60dc80006757b600bd802746ab8bb9">RandomSymmetricMatrixWithRankandRPM</a> (const Field &amp;F, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, const size_t *RRP, const size_t *CRP, RandIter &amp;G)</td></tr>
<tr class="memdesc:aaf60dc80006757b600bd802746ab8bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Symmetric Matrix with prescribed rank and rank profile matrix Creates an <code>n</code> x <code>n</code> symmetric matrix with random entries and rank <code>r</code>.  <a href="namespace_f_f_p_a_c_k.html#aaf60dc80006757b600bd802746ab8bb9">More...</a><br /></td></tr>
<tr class="separator:aaf60dc80006757b600bd802746ab8bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d59bb20ce739539b506708a469d09"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae67d59bb20ce739539b506708a469d09"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae67d59bb20ce739539b506708a469d09">RandomSymmetricMatrixWithRankandRPM</a> (const Field &amp;F, size_t M, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, const size_t *RRP, const size_t *CRP)</td></tr>
<tr class="memdesc:ae67d59bb20ce739539b506708a469d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Symmetric Matrix with prescribed rank and rank profile matrix Creates an <code>n</code> x <code>n</code> symmetric matrix with random entries and rank <code>r</code>.  <a href="namespace_f_f_p_a_c_k.html#ae67d59bb20ce739539b506708a469d09">More...</a><br /></td></tr>
<tr class="separator:ae67d59bb20ce739539b506708a469d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5df400db47b16c9ebd532f30a0da61"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a4d5df400db47b16c9ebd532f30a0da61"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4d5df400db47b16c9ebd532f30a0da61">RandomMatrixWithRankandRandomRPM</a> (const Field &amp;F, size_t M, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a4d5df400db47b16c9ebd532f30a0da61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank, with random rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random.  <a href="namespace_f_f_p_a_c_k.html#a4d5df400db47b16c9ebd532f30a0da61">More...</a><br /></td></tr>
<tr class="separator:a4d5df400db47b16c9ebd532f30a0da61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d159d4717933325a35cf6723b65ce2"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a15d159d4717933325a35cf6723b65ce2"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a15d159d4717933325a35cf6723b65ce2">RandomMatrixWithRankandRandomRPM</a> (const Field &amp;F, size_t M, size_t N, size_t R, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a15d159d4717933325a35cf6723b65ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed rank, with random rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random.  <a href="namespace_f_f_p_a_c_k.html#a15d159d4717933325a35cf6723b65ce2">More...</a><br /></td></tr>
<tr class="separator:a15d159d4717933325a35cf6723b65ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2738e3a50b07da4949a76d1df34a3e19"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a2738e3a50b07da4949a76d1df34a3e19"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a2738e3a50b07da4949a76d1df34a3e19">RandomSymmetricMatrixWithRankandRandomRPM</a> (const Field &amp;F, size_t N, size_t R, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a2738e3a50b07da4949a76d1df34a3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Symmetric Matrix with prescribed rank, with random rank profile matrix Creates an <code>n</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random.  <a href="namespace_f_f_p_a_c_k.html#a2738e3a50b07da4949a76d1df34a3e19">More...</a><br /></td></tr>
<tr class="separator:a2738e3a50b07da4949a76d1df34a3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85a5a12084e3c87e0a65fe9717fdac8"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae85a5a12084e3c87e0a65fe9717fdac8"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae85a5a12084e3c87e0a65fe9717fdac8">RandomSymmetricMatrixWithRankandRandomRPM</a> (const Field &amp;F, size_t N, size_t R, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:ae85a5a12084e3c87e0a65fe9717fdac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Symmetric Matrix with prescribed rank, with random rank profile matrix Creates an <code>n</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random.  <a href="namespace_f_f_p_a_c_k.html#ae85a5a12084e3c87e0a65fe9717fdac8">More...</a><br /></td></tr>
<tr class="separator:ae85a5a12084e3c87e0a65fe9717fdac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b9f48168255e0dc0b33dc1977f1d01"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a80b9f48168255e0dc0b33dc1977f1d01"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a80b9f48168255e0dc0b33dc1977f1d01">RandomMatrixWithDet</a> (const Field &amp;F, size_t n, const typename Field::Element d, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a80b9f48168255e0dc0b33dc1977f1d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed det.  <a href="namespace_f_f_p_a_c_k.html#a80b9f48168255e0dc0b33dc1977f1d01">More...</a><br /></td></tr>
<tr class="separator:a80b9f48168255e0dc0b33dc1977f1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e7076880d54bab70d8c243cddc959c"><td class="memTemplParams" colspan="2">template&lt;class Field , class RandIter &gt; </td></tr>
<tr class="memitem:a98e7076880d54bab70d8c243cddc959c"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a98e7076880d54bab70d8c243cddc959c">RandomMatrixWithDet</a> (const Field &amp;F, size_t n, const typename Field::Element d, typename Field::Element_ptr A, size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a98e7076880d54bab70d8c243cddc959c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random Matrix with prescribed det.  <a href="namespace_f_f_p_a_c_k.html#a98e7076880d54bab70d8c243cddc959c">More...</a><br /></td></tr>
<tr class="separator:a98e7076880d54bab70d8c243cddc959c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><b>F</b>inite <b>F</b>ield <b>PACK</b> Set of elimination based routines for dense linear algebra. </p>
<p >This namespace enlarges the set of BLAS routines of the class FFLAS, with higher level routines based on elimination. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1b1cddd27a131dabda817df0ec0b7177" name="a1b1cddd27a131dabda817df0ec0b7177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1cddd27a131dabda817df0ec0b7177">&#9670;&nbsp;</a></span>applyP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void applyP </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>Trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ibeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in P1 as a LAPACK permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P1</td><td>a LAPACK permutation of size N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P2</td><td>a LAPACK permutation of size N-R</td></tr>
  </table>
  </dd>
</dl>
<p>Applies a permutation P to the matrix A. Apply a permutation P, stored in the LAPACK format (a sequence of transpositions) between indices ibeg and iend (excluded) of P to (iend-ibeg) vectors of size M stored in A (as column for NoTrans and rows for Trans). Side==FFLAS::FflasLeft for row permutation Side==FFLAS::FflasRight for a column permutation Trans==FFLAS::FflasTrans for the inverse permutation of P </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>decides if rows (FflasLeft) or columns (FflasRight) are permuted </td></tr>
    <tr><td class="paramname">Trans</td><td>decides if the matrix is seen as columns (FflasTrans) or rows (FflasNoTrans) </td></tr>
    <tr><td class="paramname">M</td><td>size of the elements to permute </td></tr>
    <tr><td class="paramname">ibeg</td><td>first index to consider in P </td></tr>
    <tr><td class="paramname">iend</td><td>next to last index to consider in P </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">P</td><td>permutation in LAPACK format </td></tr>
    <tr><td class="paramname">psh</td><td>(optional): a sequential or parallel helper, to choose between sequential or parallel execution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>not sure the submatrix is still a permutation and the one we expect in all cases... examples for iend=2, ibeg=1 and P=[2,2,2] </dd></dl>

</div>
</div>
<a id="a2e0a8fba965dfc44b5ef07ab856ed825" name="a2e0a8fba965dfc44b5ef07ab856ed825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0a8fba965dfc44b5ef07ab856ed825">&#9670;&nbsp;</a></span>MonotonicApplyP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MonotonicApplyP </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>Trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ibeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a R-monotonically increasing permutation P, to the matrix A. </p>
<p >MonotonicApplyP Apply a permutation defined by the first R entries of the vector P (the pivots).</p>
<p >The permutation represented by P is defined as follows:</p><ul>
<li>the first R values of P is a LAPACK reprensentation (a sequence of transpositions)</li>
<li>the remaining iend-ibeg-R values of the permutation are in a monotonically increasing progression Side==FFLAS::FflasLeft for row permutation Side==FFLAS::FflasRight for a column permutation Trans==FFLAS::FflasTrans for the inverse permutation of P <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>selects if it is a row (FflasLeft) or column (FflasRight) permutation </td></tr>
    <tr><td class="paramname">Trans</td><td>inverse permutation (FflasTrans/NoTrans) </td></tr>
    <tr><td class="paramname">M</td><td></td></tr>
    <tr><td class="paramname">ibeg</td><td></td></tr>
    <tr><td class="paramname">iend</td><td></td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">P</td><td>LAPACK permuation </td></tr>
    <tr><td class="paramname">R</td><td>first values of P</td></tr>
  </table>
  </dd>
</dl>
The non pivot elements, are located in montonically increasing order. </li>
</ul>

</div>
</div>
<a id="a0a43b157c8206491f4c4e5337a3f9423" name="a0a43b157c8206491f4c4e5337a3f9423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a43b157c8206491f4c4e5337a3f9423">&#9670;&nbsp;</a></span>fgetrs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fgetrs </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the system <img class="formulaInl" alt="$A X = B$" src="form_78.png"/> or <img class="formulaInl" alt="$X A = B$" src="form_79.png"/>. </p>
<p >Solving using the <code>PLUQ</code> decomposition of <code>A</code> already computed inplace with <code>PLUQ</code> (FFLAS::FflasNonUnit). Version for A square. If A is rank deficient, a solution is returned if the system is consistent, Otherwise an info is 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>Determine wheter the resolution is left (FflasLeft) or right (FflasRight) looking. </td></tr>
    <tr><td class="paramname">M</td><td>row dimension of <code>B</code> </td></tr>
    <tr><td class="paramname">N</td><td>col dimension of <code>B</code> </td></tr>
    <tr><td class="paramname">R</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">P</td><td>row permutation of the <code>PLUQ</code> decomposition of <code>A</code> </td></tr>
    <tr><td class="paramname">Q</td><td>column permutation of the <code>PLUQ</code> decomposition of <code>A</code> </td></tr>
    <tr><td class="paramname">B</td><td>Right/Left hand side matrix. Initially stores <code>B</code>, finally stores the solution <code>X</code>. </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of <code>B</code> </td></tr>
    <tr><td class="paramname">info</td><td>Success of the computation: 0 if successfull, &gt;0 if system is inconsistent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19f62816af5c3957e5d8dcd60eed1f3f" name="a19f62816af5c3957e5d8dcd60eed1f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f62816af5c3957e5d8dcd60eed1f3f">&#9670;&nbsp;</a></span>fgetrs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr fgetrs </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the system A X = B or X A = B. </p>
<p >Solving using the PLUQ decomposition of A already computed inplace with PLUQ(FFLAS::FflasNonUnit). Version for A rectangular. If A is rank deficient, a solution is returned if the system is consistent, Otherwise an info is 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>Determine wheter the resolution is left (FflasLeft) or right (FflasRight) looking. </td></tr>
    <tr><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramname">N</td><td>col dimension of A </td></tr>
    <tr><td class="paramname">NRHS</td><td>number of columns (if Side = FFLAS::FflasLeft) or row (if Side = FFLAS::FflasRight) of the matrices X and B </td></tr>
    <tr><td class="paramname">R</td><td>rank of A </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">P</td><td>row permutation of the PLUQ decomposition of A </td></tr>
    <tr><td class="paramname">Q</td><td>column permutation of the PLUQ decomposition of A </td></tr>
    <tr><td class="paramname">X</td><td>solution matrix </td></tr>
    <tr><td class="paramname">ldx</td><td>leading dimension of X </td></tr>
    <tr><td class="paramname">B</td><td>Right/Left hand side matrix. </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">info</td><td>Succes of the computation: 0 if successfull, &gt;0 if system is inconsistent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4f26909f63a855dfeefee2d55dae1d" name="ade4f26909f63a855dfeefee2d55dae1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f26909f63a855dfeefee2d55dae1d">&#9670;&nbsp;</a></span>fgesv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fgesv </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Square system solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramname">Side</td><td>Determine wheter the resolution is left (FflasLeft) or right (FflasRight) looking </td></tr>
    <tr><td class="paramname">M</td><td>row dimension of B </td></tr>
    <tr><td class="paramname">N</td><td>col dimension of B </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">B</td><td>Right/Left hand side matrix. Initially contains B, finally contains the solution X. </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">info</td><td>Success of the computation: 0 if successfull, &gt;0 if system is inconsistent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the system</dd></dl>
<p>Solve the system A X = B or X A = B. Version for A square. If A is rank deficient, a solution is returned if the system is consistent, Otherwise an info is 1 </p>

</div>
</div>
<a id="a68ff465a100ffa4c64abd6be721c3d3d" name="a68ff465a100ffa4c64abd6be721c3d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ff465a100ffa4c64abd6be721c3d3d">&#9670;&nbsp;</a></span>fgesv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fgesv </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>NRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rectangular system solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramname">Side</td><td>Determine wheter the resolution is left (FflasLeft) or right (FflasRight) looking </td></tr>
    <tr><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramname">N</td><td>col dimension of A </td></tr>
    <tr><td class="paramname">NRHS</td><td>number of columns (if Side = FFLAS::FflasLeft) or row (if Side = FFLAS::FflasRight) of the matrices X and B </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">B</td><td>Right/Left hand side matrix. Initially contains B, finally contains the solution X. </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">X</td><td></td></tr>
    <tr><td class="paramname">ldx</td><td></td></tr>
    <tr><td class="paramname">info</td><td>Success of the computation: 0 if successfull, &gt;0 if system is inconsistent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the system</dd></dl>
<p>Solve the system A X = B or X A = B. Version for A square. If A is rank deficient, a solution is returned if the system is consistent, Otherwise an info is 1 </p>

</div>
</div>
<a id="ae8ebbf599c6c93aa1689edd3763b1887" name="ae8ebbf599c6c93aa1689edd3763b1887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ebbf599c6c93aa1689edd3763b1887">&#9670;&nbsp;</a></span>ftrtri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ftrtri </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>__FFLASFFPACK_FTRTRI_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse of a triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Uplo</td><td>whether the matrix is upper or lower triangular </td></tr>
    <tr><td class="paramname">Diag</td><td>whether the matrix is unit diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramname">N</td><td>input matrix order </td></tr>
    <tr><td class="paramname">A</td><td>the input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c38fdc258c7071c3d4ff39ee419a9c" name="ab7c38fdc258c7071c3d4ff39ee419a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c38fdc258c7071c3d4ff39ee419a9c">&#9670;&nbsp;</a></span>ftrtrm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ftrtrm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the product of two triangular matrices of opposite shape. </p>
<p >Product UL or LU of the upper, resp lower triangular matrices U and L stored one above the other in the square matrix A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>set to FflasLeft to compute the product UL, FflasRight to compute LU </td></tr>
    <tr><td class="paramname">diag</td><td>whether the matrix U is unit diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramname">N</td><td>input matrix order </td></tr>
    <tr><td class="paramname">A</td><td>the input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adece02815384390d9693661abee012ed" name="adece02815384390d9693661abee012ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adece02815384390d9693661abee012ed">&#9670;&nbsp;</a></span>ftrstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ftrstr </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diagA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diagB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve a triangular system with a triangular right hand side of the same shape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Side</td><td>set to FflasLeft to compute U1^-1*U2 or L1^-1*L2, FflasRight to compute U1*U2^-1 or L1*L2^-1 </td></tr>
    <tr><td class="paramname">Uplo</td><td>whether the matrix A is upper or lower triangular </td></tr>
    <tr><td class="paramname">diag1</td><td>whether the matrix U1 or L2 is unit diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramname">diag2</td><td>whether the matrix U2 or L2 is unit diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramname">N</td><td>order of the input matrices </td></tr>
    <tr><td class="paramname">A</td><td>the input matrix to be inverted (U1 or L1) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">B</td><td>the input right hand side (U2 or L2) </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72941c6ae84659f44db2b096458bda56" name="a72941c6ae84659f44db2b096458bda56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72941c6ae84659f44db2b096458bda56">&#9670;&nbsp;</a></span>ftrssyr2k()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ftrssyr2k </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diagA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve a triangular system in a symmetric sum: find B upper/lower triangular such that A^T B + B^T A = C where C is symmetric. </p>
<p >C is overwritten by B. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td>set to FflasLeft to compute U1^-1*U2 or L1^-1*L2, FflasRight to compute U1*U2^-1 or L1*L2^-1 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Uplo</td><td>whether the matrix A is upper or lower triangular </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diagA</td><td>whether the matrix A is unit diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the input matrices </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>the input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>the input right hand side where the output is written </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abea15a71392b8116270ba58d44f99b0a" name="abea15a71392b8116270ba58d44f99b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea15a71392b8116270ba58d44f99b0a">&#9670;&nbsp;</a></span>fsytrf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsytrf </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>UpLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>__FFLASFFPACK_FSYTRF_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangular factorization of symmetric matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>Determine wheter to store the upper (FflasUpper) or lower (FflasLower) triangular factor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the <code>A</code> does not have generic rank profile, making the computation fail.</dd></dl>
<p>Compute the a triangular factorization of the matrix A: <img class="formulaInl" alt="$ A = L \times D \times  L^T$" src="form_80.png"/> if UpLo = FflasLower or <img class="formulaInl" alt="$ A = U^T \times D \times  U$" src="form_81.png"/> otherwise. <code>D</code> is a diagonal matrix. The matrices <code>L</code> and <code>U</code> are unit diagonal lower (resp. upper) triangular and overwrite the input matrix <code>A</code>. The matrix <code>D</code> is stored on the diagonal of <code>A</code>, as the diagonal of <code>L</code> or <code>U</code> is known to be all ones. If A does not have generic rank profile, the LDLT or UTDU factorizations is not defined, and the algorithm returns false. </p>

</div>
</div>
<a id="a03905818bbd609ea0318414856d20374" name="a03905818bbd609ea0318414856d20374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03905818bbd609ea0318414856d20374">&#9670;&nbsp;</a></span>fsytrf_nonunit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fsytrf_nonunit </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>UpLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>incD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>__FFLASFFPACK_FSYTRF_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangular factorization of symmetric matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>Determine wheter to store the upper (FflasUpper) or lower (FflasLower) triangular factor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the <code>A</code> does not have generic rank profile, making the computation fail.</dd></dl>
<p>Compute the a triangular factorization of the matrix A: <img class="formulaInl" alt="$ A = L \times Dinv \times  L^T$" src="form_82.png"/> if UpLo = FflasLower or <img class="formulaInl" alt="$ A = U^T \times D \times  U$" src="form_81.png"/> otherwise. <code>D</code> is a diagonal matrix. The matrices <code>L</code> and <code>U</code> are lower (resp. upper) triangular and overwrite the input matrix <code>A</code>. The matrix <code>D</code> need to be stored separately, as the diagonal of <code>L</code> or <code>U</code> are not unit. If A does not have generic rank profile, the LDLT or UTDU factorizations is not defined, and the algorithm returns false. </p>

</div>
</div>
<a id="a834f90809584dae59b27fec78c77e927" name="a834f90809584dae59b27fec78c77e927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f90809584dae59b27fec78c77e927">&#9670;&nbsp;</a></span>PLUQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t PLUQ </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a PLUQ factorization of the given matrix; such that A=PLUQ. </p>
<p >Return its rank. The permutations P and Q are represented using LAPACK's convention. Instead of P, the routines produces Pt, a LAPACK representation of P^T </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Diag</td><td>whether U should have a unit diagonal (FflasUnit) or not (FflasNoUnit) </td></tr>
    <tr><td class="paramname">M</td><td>matrix row dimension </td></tr>
    <tr><td class="paramname">N</td><td>matrix column dimension </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">Pt</td><td>the transpose of row permutation P </td></tr>
    <tr><td class="paramname">Q</td><td>the column permutation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of <code>A</code> </dd></dl>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000007">Bibliography:</a></b></dt><dd><ul>
<li>Dumas J-G., Pernet C., and Sultan Z. <em><code>Simultaneous</code> computation of the row and column rank profiles </em>, ISSAC'13, 2013</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8167a1477d10a7367cce30923281b0fe" name="a8167a1477d10a7367cce30923281b0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8167a1477d10a7367cce30923281b0fe">&#9670;&nbsp;</a></span>LUdivine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LUdivine </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>__FFLASFFPACK_LUDIVINE_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the CUP or PLE factorization of the given matrix. </p>
<p >Using a block algorithm and return its rank. The permutations P and Q are represented using LAPACK's convention. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">Diag</td><td>whether the transformation matrix (U of the CUP, L of the PLE) should have a unit diagonal (FflasUnit) or not (FflasNoUnit) </td></tr>
    <tr><td class="paramname">trans</td><td>whether to compute the CUP decomposition (FflasNoTrans) or the PLE decomposition (FflasTrans) </td></tr>
    <tr><td class="paramname">M</td><td>matrix row dimension </td></tr>
    <tr><td class="paramname">N</td><td>matrix column dimension </td></tr>
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">P</td><td>the factor of CUP or PLE </td></tr>
    <tr><td class="paramname">Q</td><td>a permutation indicating the pivot position in the echelon form C or E in its first r positions </td></tr>
    <tr><td class="paramname">LuTag</td><td>flag for setting the earling termination if the matrix is singular </td></tr>
    <tr><td class="paramname">cutoff</td><td>threshold to basecase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of <code>A</code> </dd></dl>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000008">Bibliography:</a></b></dt><dd><ul>
<li>Jeannerod C-P, Pernet, C. and Storjohann, A. <em><code>Rank-profile</code> revealing Gaussian elimination and the CUP matrix decomposition </em>, J. of Symbolic Comp., 2013</li>
<li>Pernet C, Brassel M <em><code>LUdivine</code>, une divine factorisation <code>LU</em></code>, 2002</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a150d6acb28e77ec56949bf99dd8e3e73" name="a150d6acb28e77ec56949bf99dd8e3e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150d6acb28e77ec56949bf99dd8e3e73">&#9670;&nbsp;</a></span>ColumnEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColumnEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transform</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Column Echelon form of the input matrix in-place. </p>
<p >If LuTag == FfpackTileRecursive, then after the computation A = [ M \ V ] such that AU = C is a column echelon decomposition of A, with U = P^T [ V ] and C = M + Q [ Ir ] [ 0 In-r ] [ 0 ] If LuTag == FfpackTileRecursive then A = [ N \ V ] such that the same holds with M = Q N</p>
<p >Qt = Q^T If transform=false, the matrix V is not computed. See also test-colechelon for an example of use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the column permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Qt</td><td>the row position of the pivots in the echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">transform</td><td>decides whether V is computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a8223494b06149b4db058c56b25083" name="aa5a8223494b06149b4db058c56b25083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a8223494b06149b4db058c56b25083">&#9670;&nbsp;</a></span>RowEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RowEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transform</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Row Echelon form of the input matrix in-place. </p>
<p >If LuTag == FfpackTileRecursive, then after the computation A = [ L \ M ] such that X A = R is a row echelon decomposition of A, with X = [ L 0 ] P and R = M + [Ir 0] Q^T [ In-r] If LuTag == FfpackTileRecursive then A = [ L \ N ] such that the same holds with M = N Q^T Qt = Q^T If transform=false, the matrix L is not computed. See also test-rowechelon for an example of use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the row permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Qt</td><td>the column position of the pivots in the echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">transform</td><td>decides whether L is computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a813e34d18a3de299b26bd9de2c8e4b4d" name="a813e34d18a3de299b26bd9de2c8e4b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813e34d18a3de299b26bd9de2c8e4b4d">&#9670;&nbsp;</a></span>ReducedColumnEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ReducedColumnEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transform</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Reduced Column Echelon form of the input matrix in-place. </p>
<p >After the computation A = [ V ] such that AX = R is a reduced col echelon [ M 0 ] decomposition of A, where X = P^T [ V ] and R = Q [ Ir ] [ 0 In-r ] [ M 0 ] Qt = Q^T If transform=false, the matrix X is not computed and the matrix A = R</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the column permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Qt</td><td>the row position of the pivots in the echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">transform</td><td>decides whether X is computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9aba43cbf35752df1c5c5f24193fb2a" name="ab9aba43cbf35752df1c5c5f24193fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aba43cbf35752df1c5c5f24193fb2a">&#9670;&nbsp;</a></span>ReducedRowEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ReducedRowEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Qt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transform</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Reduced Row Echelon form of the input matrix in-place. </p>
<p >After the computation A = [ V1 M ] such that X A = R is a reduced row echelon [ V2 0 ] decomposition of A, where X = [ V1 0 ] P and R = [ Ir M ] Q^T [ V2 In-r ] [ 0 ] Qt = Q^T If transform=false, the matrix X is not computed and the matrix A = R </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the row permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Qt</td><td>the column position of the pivots in the echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">transform</td><td>decides whether X is computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62197ee1bbc40b25843361f574bf9748" name="a62197ee1bbc40b25843361f574bf9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62197ee1bbc40b25843361f574bf9748">&#9670;&nbsp;</a></span>Invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr Invert </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nullity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the given matrix in place or computes its nullity if it is singular. </p>
<p >An inplace <img class="formulaInl" alt="$2n^3$" src="form_83.png"/> algorithm is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>order of the matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix ( <img class="formulaInl" alt="$M \times M$" src="form_84.png"/>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nullity</td><td>dimension of the kernel of A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <img class="formulaInl" alt="$A$" src="form_59.png"/> and <img class="formulaInl" alt="$A \gets A^{-1}$" src="form_85.png"/> </dd></dl>

</div>
</div>
<a id="a4336928c74f094a5ddebcec18bb17bb5" name="a4336928c74f094a5ddebcec18bb17bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4336928c74f094a5ddebcec18bb17bb5">&#9670;&nbsp;</a></span>Invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr Invert </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nullity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the given matrix or computes its nullity if it is singular. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>X</code> is preallocated and should be large enough to store the <img class="formulaInl" alt="$ m \times m$" src="form_86.png"/> matrix <code>A</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>order of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix ( <img class="formulaInl" alt="$M \times M$" src="form_84.png"/>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>this is the inverse of <code>A</code> if <code>A</code> is invertible (non <code>NULL</code> and <img class="formulaInl" alt="$ \mathtt{nullity} = 0$" src="form_87.png"/>). It is untouched otherwise. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldx</td><td>leading dimension of <code>X</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nullity</td><td>dimension of the kernel of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <img class="formulaInl" alt="$X = A^{-1}$" src="form_88.png"/> </dd></dl>

</div>
</div>
<a id="a681c044c0d4533c4387ef15e867fd886" name="a681c044c0d4533c4387ef15e867fd886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681c044c0d4533c4387ef15e867fd886">&#9670;&nbsp;</a></span>Invert2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr Invert2 </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nullity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the given matrix or computes its nullity if it is singular. </p>
<p >An <img class="formulaInl" alt="$2n^3f$" src="form_89.png"/> algorithm is used. This routine can be % faster than <a class="el" href="namespace_f_f_p_a_c_k.html#a62197ee1bbc40b25843361f574bf9748" title="Invert the given matrix in place or computes its nullity if it is singular.">FFPACK::Invert</a> but is not totally inplace.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>X</code> is preallocated and should be large enough to store the <img class="formulaInl" alt="$ m \times m$" src="form_86.png"/> matrix <code>A</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A is overwritten here ! </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000017">Bug:</a></b></dt><dd>not tested. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>the computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>order of the matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix ( <img class="formulaInl" alt="$M \times M$" src="form_84.png"/>). On output, <code>A</code> is modified and represents a "psycological" factorisation <code>LU</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>this is the inverse of <code>A</code> if <code>A</code> is invertible (non <code>NULL</code> and <img class="formulaInl" alt="$ \mathtt{nullity} = 0$" src="form_87.png"/>). It is untouched otherwise. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldx</td><td>leading dimension of <code>X</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nullity</td><td>dimension of the kernel of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <img class="formulaInl" alt="$X = A^{-1}$" src="form_88.png"/> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>this init is not all necessary (done after ftrtri) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>this init is not all necessary (done after ftrtri) </dd></dl>

</div>
</div>
<a id="a1d3e9f9fe5ff9d62e286be6eda2b01bf" name="a1d3e9f9fe5ff9d62e286be6eda2b01bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3e9f9fe5ff9d62e286be6eda2b01bf">&#9670;&nbsp;</a></span>CharPoly() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; typename PolRing::Element &gt; &amp; CharPoly </td>
          <td>(</td>
          <td class="paramtype">const PolRing &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename PolRing::Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>charp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_CHARPOLY_TAG&#160;</td>
          <td class="paramname"><em>CharpTag</em> = <code>FfpackAuto</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em> = <code>__FFLASFFPACK_ARITHPROG_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the characteristic polynomial of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>the polynomial ring of charp (contains the base field) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">charp</td><td>the characteristic polynomial of <code>as</code> a list of factors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) (could be overwritten in some algorithmic variants) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CharpTag</td><td>the algorithmic variant </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator (required for the randomized variants LUKrylov and ArithProg) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12460cbc0f7735e5c6ac5eaba73a17b" name="af12460cbc0f7735e5c6ac5eaba73a17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12460cbc0f7735e5c6ac5eaba73a17b">&#9670;&nbsp;</a></span>CharPoly() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PolRing::Element &amp; CharPoly </td>
          <td>(</td>
          <td class="paramtype">const PolRing &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Element &amp;&#160;</td>
          <td class="paramname"><em>charp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_CHARPOLY_TAG&#160;</td>
          <td class="paramname"><em>CharpTag</em> = <code>FfpackAuto</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em> = <code>__FFLASFFPACK_ARITHPROG_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the characteristic polynomial of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>the polynomial ring of charp (contains the base field) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">charp</td><td>the characteristic polynomial of <code>as</code> a single polynomial </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) (could be overwritten in some algorithmic variants) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CharpTag</td><td>the algorithmic variant </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator (required for the randomized variants LUKrylov and ArithProg) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c2bcea333b6c2732fde289f3c572c00" name="a8c2bcea333b6c2732fde289f3c572c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2bcea333b6c2732fde289f3c572c00">&#9670;&nbsp;</a></span>CharPoly() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PolRing::Element &amp; CharPoly </td>
          <td>(</td>
          <td class="paramtype">const PolRing &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Element &amp;&#160;</td>
          <td class="paramname"><em>charp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_CHARPOLY_TAG&#160;</td>
          <td class="paramname"><em>CharpTag</em> = <code>FfpackAuto</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em> = <code>__FFLASFFPACK_ARITHPROG_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the characteristic polynomial of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>the polynomial ring of charp (contains the base field) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">charp</td><td>the characteristic polynomial of <code>as</code> a single polynomial </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) (could be overwritten in some algorithmic variants) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CharpTag</td><td>the algorithmic variant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a225ba4356fcea2d470835ead0278237e" name="a225ba4356fcea2d470835ead0278237e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225ba4356fcea2d470835ead0278237e">&#9670;&nbsp;</a></span>MinPoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial &amp; MinPoly </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>minP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimal polynomial of the matrix A. </p>
<p >The algorithm is randomized probabilistic, and computes the minimal polynomial of the Krylov iterates of a random vector: (v, Av, .., A^kv) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>the base field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minP</td><td>the minimal polynomial of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a862701a92e6d2b12e40b5a7f6b2e06ee" name="a862701a92e6d2b12e40b5a7f6b2e06ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862701a92e6d2b12e40b5a7f6b2e06ee">&#9670;&nbsp;</a></span>MinPoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial &amp; MinPoly </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>minP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimal polynomial of the matrix A. </p>
<p >The algorithm is randomized probabilistic, and computes the minimal polynomial of the Krylov iterates of a random vector: (v, Av, .., A^kv) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>the base field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minP</td><td>the minimal polynomial of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1eeaee05c99ce77fa38b64e8fe1fa11" name="ac1eeaee05c99ce77fa38b64e8fe1fa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eeaee05c99ce77fa38b64e8fe1fa11">&#9670;&nbsp;</a></span>MatVecMinPoly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial &amp; MatVecMinPoly </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>minP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>incv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimal polynomial of the matrix A and a vector v, namely the first linear dependency relation in the Krylov basis <img class="formulaInl" alt="$(v,Av, ..., A^Nv)$" src="form_91.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>the base field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minP</td><td>the minimal polynomial of <code>A</code> and v </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>order of the matrix <code>A</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the input matrix ( <img class="formulaInl" alt="$ N \times N$" src="form_90.png"/>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">K</td><td>an <img class="formulaInl" alt="$ N \times (N+1)$" src="form_92.png"/> matrix containing the vector v on its first row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldk</td><td>leading dimension of <code>K</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>[out] (optional) the permutation used in the elimination of the Krylov matrix <code>K</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb286015f6161e817d28298ac7f02e7e" name="afb286015f6161e817d28298ac7f02e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb286015f6161e817d28298ac7f02e7e">&#9670;&nbsp;</a></span>Rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Rank </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rank of the given matrix using a PLUQ factorization. </p>
<p >The input matrix is modified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of the matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">psH</td><td>(optional) a ParSeqHelper to choose between sequential and parallel execution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a231910d94ef4832edb786ceb8574cace" name="a231910d94ef4832edb786ceb8574cace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231910d94ef4832edb786ceb8574cace">&#9670;&nbsp;</a></span>IsSingular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsSingular </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given matrix is singular. </p>
<p >The method is a block elimination with early termination</p>
<p >using LQUP factorization with early termination. If <code>M != N</code>, then the matrix is virtually padded with zeros to make it square and it's determinant is zero. </p><dl class="section warning"><dt>Warning</dt><dd>The input matrix is modified. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of the matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of the matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82f1c3a47ce5b9ee39c5ac44864add93" name="a82f1c3a47ce5b9ee39c5ac44864add93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f1c3a47ce5b9ee39c5ac44864add93">&#9670;&nbsp;</a></span>Det()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element &amp; Det </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element &amp;&#160;</td>
          <td class="paramname"><em>det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Q</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the given square matrix. </p>
<p >The method is a block elimination using PLUQ factorization. The input matrix A is overwritten. </p><dl class="section warning"><dt>Warning</dt><dd>The input matrix is modified. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">det</td><td>the determinant of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the order of the square matrix A. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">psH</td><td>(optional) a ParSeqHelper to choose between sequential and parallel execution </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P,Q</td><td>(optional) row and column permutations to be used by the PLUQ factorization. randomized checkers (see cherckes/checker_det.inl) need them for certification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b24993d207d33830edf3286f7332631" name="a8b24993d207d33830edf3286f7332631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b24993d207d33830edf3286f7332631">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr Solve </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a linear system AX = b using PLUQ factorization. </p>
<p >@oaram F base field @oaram M matrix order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>output solution vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">incx</td><td>increment of x </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>input right hand side of the system </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">incb</td><td>increment of b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f559150c4ef2579bbd9dcd0b97eef30" name="a4f559150c4ef2579bbd9dcd0b97eef30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f559150c4ef2579bbd9dcd0b97eef30">&#9670;&nbsp;</a></span>RandomNullSpaceVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">*void RandomNullSpaceVector </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve L X = B or X L = B in place. </p>
<p >L is M*M if Side == FFLAS::FflasLeft and N*N if Side == FFLAS::FflasRight, B is M*N. Only the R non trivial column of L are stored in the M*R matrix L Requirement : so that L could be expanded in-place Computes a vector of the Left/Right nullspace of the matrix A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td>decides whether it computes the left (FflasLeft) or right (FflasRight) nullspace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix of dimension M x N, A is modified to its LU version </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>output vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a668c07f738a5d813fc1ff7d0b60cd4ef" name="a668c07f738a5d813fc1ff7d0b60cd4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668c07f738a5d813fc1ff7d0b60cd4ef">&#9670;&nbsp;</a></span>NullSpaceBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t NullSpaceBasis </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr &amp;&#160;</td>
          <td class="paramname"><em>NS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>ldn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>NSdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a basis of the Left/Right nullspace of the matrix A. </p>
<p >return the dimension of the nullspace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td>decides whether it computes the left (FflasLeft) or right (FflasRight) nullspace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix of dimension M x N, A is modified </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NS</td><td>output matrix of dimension N x NSdim (allocated here) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ldn</td><td>leading dimension of NS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NSdim</td><td>the dimension of the Nullspace (N-rank(A)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b01710a3a14e5ddeff63e7dde312e5" name="a61b01710a3a14e5ddeff63e7dde312e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b01710a3a14e5ddeff63e7dde312e5">&#9670;&nbsp;</a></span>RowRankProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RowRankProfile </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>rkprofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the row rank profile of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension M x N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rkprofile</td><td>return the rank profile as an array of row indexes, of dimension r=rank(A) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ</td></tr>
  </table>
  </dd>
</dl>
<p>A is modified rkprofile is allocated during the computation. </p><dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="ad2a30cbb378686c18f8fda52a2ea692c" name="ad2a30cbb378686c18f8fda52a2ea692c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a30cbb378686c18f8fda52a2ea692c">&#9670;&nbsp;</a></span>ColumnRankProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColumnRankProfile </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>rkprofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the column rank profile of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rkprofile</td><td>return the rank profile as an array of row indexes, of dimension r=rank(A) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ</td></tr>
  </table>
  </dd>
</dl>
<p>A is modified rkprofile is allocated during the computation. </p><dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="a210f3ceeca532699f4567098c22e0c30" name="a210f3ceeca532699f4567098c22e0c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210f3ceeca532699f4567098c22e0c30">&#9670;&nbsp;</a></span>RankProfileFromLU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RankProfileFromLU </td>
          <td>(</td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>rkprofile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers the column/row rank profile from the permutation of an LU decomposition. </p>
<p >Works with both the CUP/PLE decompositions (obtained by LUdivine) or the PLUQ decomposition. Assumes that the output vector containing the rank profile is already allocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the permutation carrying the rank profile information </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the row/col dimension for a row/column rank profile </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>the rank of the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rkprofile</td><td>return the rank profile as an array of indices </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>chooses the elimination algorithm. SlabRecursive for LUdivine, TileRecursive for PLUQ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6732312bd3b9111ed2beda4d4989407" name="ab6732312bd3b9111ed2beda4d4989407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6732312bd3b9111ed2beda4d4989407">&#9670;&nbsp;</a></span>LeadingSubmatrixRankProfiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LeadingSubmatrixRankProfiles </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>LSm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>LSn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>RRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>CRP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers the row and column rank profiles of any leading submatrix from the PLUQ decomposition. </p>
<p >Only works with the PLUQ decomposition Assumes that the output vectors containing the rank profiles are already allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>the permutation carrying the rank profile information </td></tr>
    <tr><td class="paramname">M</td><td>the row dimension of the initial matrix </td></tr>
    <tr><td class="paramname">N</td><td>the column dimension of the initial matrix </td></tr>
    <tr><td class="paramname">R</td><td>the rank of the initial matrix </td></tr>
    <tr><td class="paramname">LSm</td><td>the row dimension of the leading submatrix considered </td></tr>
    <tr><td class="paramname">LSn</td><td>the column dimension of the leading submatrix considered </td></tr>
    <tr><td class="paramname">P</td><td>the row permutation of the PLUQ decomposition </td></tr>
    <tr><td class="paramname">Q</td><td>the column permutation of the PLUQ decomposition </td></tr>
    <tr><td class="paramname">RRP</td><td>return the row rank profile of the leading submatrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank of the LSm x LSn leading submatrix</dd></dl>
<p>A is modified </p><dl class="bib"><dt><b><a class="el" href="bib.html#_bib000010">Bibliography:</a></b></dt><dd><ul>
<li>Dumas J-G., Pernet C., and Sultan Z. <em><code>Simultaneous</code> computation of the row and column rank profiles </em>, ISSAC'13. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9101aa5d87ae4ffcacf3f5ea97fdd4df" name="a9101aa5d87ae4ffcacf3f5ea97fdd4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9101aa5d87ae4ffcacf3f5ea97fdd4df">&#9670;&nbsp;</a></span>RowRankProfileSubmatrixIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t RowRankProfileSubmatrixIndices </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>rowindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>colindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RowRankProfileSubmatrixIndices. </p>
<p >Computes the indices of the submatrix r*r X of A whose rows correspond to the row rank profile of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowindices</td><td>array of the row indices of X in A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">colindices</td><td>array of the col indices of X in A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>list of indices</td></tr>
  </table>
  </dd>
</dl>
<p>rowindices and colindices are allocated during the computation. A is modified </p><dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="ad6a8f20a642f161be15d54e9e84a276f" name="ad6a8f20a642f161be15d54e9e84a276f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a8f20a642f161be15d54e9e84a276f">&#9670;&nbsp;</a></span>ColRankProfileSubmatrixIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColRankProfileSubmatrixIndices </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>rowindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>colindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the indices of the submatrix r*r X of A whose columns correspond to the column rank profile of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rowindices</td><td>array of the row indices of X in A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">colindices</td><td>array of the col indices of X in A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>list of indices</td></tr>
  </table>
  </dd>
</dl>
<p>rowindices and colindices are allocated during the computation. </p><dl class="section warning"><dt>Warning</dt><dd>A is modified </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="ae44ada9ac14df2273cd42d5844b4fa4a" name="ae44ada9ac14df2273cd42d5844b4fa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44ada9ac14df2273cd42d5844b4fa4a">&#9670;&nbsp;</a></span>RowRankProfileSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t RowRankProfileSubmatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the r*r submatrix X of A, by picking the row rank profile rows of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension M x N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>the output matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>list of indices</td></tr>
  </table>
  </dd>
</dl>
<p>A is not modified X is allocated during the computation. </p><dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="aa6a8a8befa801a6defffa9043081cb60" name="aa6a8a8befa801a6defffa9043081cb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a8a8befa801a6defffa9043081cb60">&#9670;&nbsp;</a></span>ColRankProfileSubmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ColRankProfileSubmatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the <img class="formulaInl" alt="$ r\times r$" src="form_93.png"/> submatrix X of A, by picking the row rank profile rows of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix of dimension M x N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>the output matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>list of indices</td></tr>
  </table>
  </dd>
</dl>
<p>A is not modified X is allocated during the computation. </p><dl class="section return"><dt>Returns</dt><dd>R </dd></dl>

</div>
</div>
<a id="a00545c213322e599f00bfa88dda0b201" name="a00545c213322e599f00bfa88dda0b201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00545c213322e599f00bfa88dda0b201">&#9670;&nbsp;</a></span>getTriangular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getTriangular </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>OnlyNonZeroVectors</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a triangular matrix from a compact storage A=L\U of rank R. </p>
<p >if OnlyNonZeroVectors is false, then T and A have the same dimensions Otherwise, T is R x N if UpLo = FflasUpper, else T is M x R </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is returned </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the triangular matrix unit-diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix (how many rows/columns need to be copied) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">OnlyNonZeroVectors</td><td>decides whether the last zero rows/columns should be ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>just one triangular fzero+fassign ? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>just one triangular fzero+fassign ? </dd></dl>

</div>
</div>
<a id="ab9639c015458dc8849bc463bbcb1da1f" name="ab9639c015458dc8849bc463bbcb1da1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9639c015458dc8849bc463bbcb1da1f">&#9670;&nbsp;</a></span>getTriangular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getTriangular </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up a compact storage A=L\U to reveal a triangular matrix of rank R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is revealed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the triangular matrix unit-diagonal (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input/output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>just one triangular fzero+fassign ? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>just one triangular fzero+fassign ? </dd></dl>

</div>
</div>
<a id="aef728bf19985baf2a219feac8cb28929" name="aef728bf19985baf2a219feac8cb28929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef728bf19985baf2a219feac8cb28929">&#9670;&nbsp;</a></span>getEchelonForm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>OnlyNonZeroVectors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm. </p>
<p >Either L or U is in Echelon form (depending on Uplo) The echelon structure is defined by the first R values of the array P. row and column dimension of T are greater or equal to that of A </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is returned </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix (how many rows/columns need to be copied) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>positions of the R pivots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">OnlyNonZeroVectors</td><td>decides whether the last zero rows/columns should be ignored </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae248d48e7687959fa602ea13fdb8bf4a" name="ae248d48e7687959fa602ea13fdb8bf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae248d48e7687959fa602ea13fdb8bf4a">&#9670;&nbsp;</a></span>getEchelonForm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up a compact storage A=L\U obtained by RowEchelonForm or ColumnEchelonForm to reveal an echelon form of rank R. </p>
<p >Either L or U is in Echelon form (depending on Uplo) The echelon structure is defined by the first R values of the array P. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is returned </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix (how many rows/columns need to be copied) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>positions of the R pivots </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input/output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee39112d215c8f520c8a8409dfcb82b5" name="aee39112d215c8f520c8a8409dfcb82b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee39112d215c8f520c8a8409dfcb82b5">&#9670;&nbsp;</a></span>getEchelonTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getEchelonTransform </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm. </p>
<p >If Uplo == FflasLower: T is N x N (already allocated) such that A T = C is a transformation of A in Column echelon form Else T is M x M (already allocated) such that T A = E is a transformation of A in Row Echelon form </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>Lower (FflasLower) means Transformation to Column Echelon Form, Upper (FflasUpper), to Row Echelon Form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>permutation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae330c736c7e0c7eb585d7885bd70004b" name="ae330c736c7e0c7eb585d7885bd70004b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae330c736c7e0c7eb585d7885bd70004b">&#9670;&nbsp;</a></span>getReducedEchelonForm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getReducedEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>OnlyNonZeroVectors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true. </p>
<p >Either L or U is in Echelon form (depending on Uplo) The echelon structure is defined by the first R values of the array P. row and column dimension of T are greater or equal to that of A </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is returned </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix (how many rows/columns need to be copied) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>positions of the R pivots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">OnlyNonZeroVectors</td><td>decides whether the last zero rows/columns should be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab82ac3be0b0c94ca64f73e84952e9466" name="ab82ac3be0b0c94ca64f73e84952e9466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82ac3be0b0c94ca64f73e84952e9466">&#9670;&nbsp;</a></span>getReducedEchelonForm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getReducedEchelonForm </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true. </p>
<p >Either L or U is in Echelon form (depending on Uplo) The echelon structure is defined by the first R values of the array P. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects if the upper (FflasUpper) or lower (FflasLower) triangular matrix is returned </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix (how many rows/columns need to be copied) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>positions of the R pivots </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input/output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4e646e2d8b711a662e010c74ad57b82" name="af4e646e2d8b711a662e010c74ad57b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e646e2d8b711a662e010c74ad57b82">&#9670;&nbsp;</a></span>getReducedEchelonTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getReducedEchelonTransform </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em> = <code>FfpackSlabRecursive</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm. </p>
<p >If Uplo == FflasLower: T is N x N (already allocated) such that A T = C is a transformation of A in Column echelon form Else T is M x M (already allocated) such that T A = E is a transformation of A in Row Echelon form </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>selects Col (FflasLower) or Row (FflasUpper) Echelon Form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diag</td><td>selects if the echelon matrix has unit pivots (FflasUnit/NoUnit) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>rank of the triangular matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>permutation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>which factorized form (CUP/PLE if FfpackSlabRecursive, PLUQ if FfpackTileRecursive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3229b60de912473f3ce4cb3df8753e" name="a9c3229b60de912473f3ce4cb3df8753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3229b60de912473f3ce4cb3df8753e">&#9670;&nbsp;</a></span>LTBruhatGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LTBruhatGen </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LTBruhatGen Suppose A is Left Triangular Matrix This procedure computes the Bruhat Representation of A and return the rank of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td>base Field </td></tr>
    <tr><td class="paramname">diag</td><td></td></tr>
    <tr><td class="paramname">N</td><td>size of A </td></tr>
    <tr><td class="paramname">A</td><td>the matrix we search the Bruhat representation </td></tr>
    <tr><td class="paramname">lda</td><td>the leading dimension of A </td></tr>
    <tr><td class="paramname">P</td><td>a permutation matrix </td></tr>
    <tr><td class="paramname">Q</td><td>a permutation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9d34e03d5e3d7d413acd1947a821a7f" name="ae9d34e03d5e3d7d413acd1947a821a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d34e03d5e3d7d413acd1947a821a7f">&#9670;&nbsp;</a></span>getLTBruhatGen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getLTBruhatGen </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GetLTBruhatGen This procedure Computes the Rank Revealing Matrix based on the Bruhta representation of a Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td>base Field </td></tr>
    <tr><td class="paramname">N</td><td>size of the matrix </td></tr>
    <tr><td class="paramname">r</td><td>the rank of the matrix </td></tr>
    <tr><td class="paramname">P</td><td>a permutation matrix </td></tr>
    <tr><td class="paramname">Q</td><td>a permutation matrix </td></tr>
    <tr><td class="paramname">R</td><td>the matrix that will contain the rank revealing matrix </td></tr>
    <tr><td class="paramname">ldr</td><td>the leading fimension of R </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4970621f589c8a8c0e26dbb8a61d386f" name="a4970621f589c8a8c0e26dbb8a61d386f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4970621f589c8a8c0e26dbb8a61d386f">&#9670;&nbsp;</a></span>getLTBruhatGen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getLTBruhatGen </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GetLTBruhatGen This procedure computes the matrix L or U f the Bruhat Representation Suppose that A is the bruhat representation of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td>base Field </td></tr>
    <tr><td class="paramname">Uplo</td><td>choose if the procedure return L or U </td></tr>
    <tr><td class="paramname">diag</td><td></td></tr>
    <tr><td class="paramname">N</td><td>size of A </td></tr>
    <tr><td class="paramname">r</td><td>rank of A </td></tr>
    <tr><td class="paramname">P</td><td>permutaion matrix </td></tr>
    <tr><td class="paramname">Q</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">A</td><td>a bruhat representation </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">T</td><td>matrix that will contains L or U </td></tr>
    <tr><td class="paramname">ldt</td><td>leading dimension of T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39434278672787e41dff88fc5977d8b6" name="a39434278672787e41dff88fc5977d8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39434278672787e41dff88fc5977d8b6">&#9670;&nbsp;</a></span>LTQSorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LTQSorder </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LTQSorder This procedure computes the order of quasiseparability of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>size of the matrix </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix </td></tr>
    <tr><td class="paramname">P</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">Q</td><td>permutation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4c6629de5a1a0349eac3c1d2b73f1a1" name="ac4c6629de5a1a0349eac3c1d2b73f1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c6629de5a1a0349eac3c1d2b73f1a1">&#9670;&nbsp;</a></span>CompressToBlockBiDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CompressToBlockBiDiagonal </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CompressToBlockBiDiagonal This procedure compress a compact representation of a row echelon form or column echelon form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td>base Field </td></tr>
    <tr><td class="paramname">Uplo</td><td>chosse if the procedure is based on row or column </td></tr>
    <tr><td class="paramname">N</td><td>size of the matrix </td></tr>
    <tr><td class="paramname">s</td><td>order of qausiseparability </td></tr>
    <tr><td class="paramname">r</td><td>rank </td></tr>
    <tr><td class="paramname">P</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">Q</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">A</td><td>the matrix to compact </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">X</td><td>matrix that will stock the representation </td></tr>
    <tr><td class="paramname">ldx</td><td>leading dimension of X </td></tr>
    <tr><td class="paramname">K</td><td>stock the position of the blocks in A </td></tr>
    <tr><td class="paramname">M</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">T</td><td>stock the operation done in the procedure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4354fca8409da50f288d59c69a888970" name="a4354fca8409da50f288d59c69a888970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4354fca8409da50f288d59c69a888970">&#9670;&nbsp;</a></span>ExpandBlockBiDiagonalToBruhat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ExpandBlockBiDiagonalToBruhat </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>Uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NbBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ExpandBlockBiDiagonal This procedure expand a compact representation of a row echelon form or column echelon form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td>base Field </td></tr>
    <tr><td class="paramname">Uplo</td><td>chosse if the procedure is based on row or column </td></tr>
    <tr><td class="paramname">N</td><td>size of the matrix </td></tr>
    <tr><td class="paramname">s</td><td>order of qausiseparability </td></tr>
    <tr><td class="paramname">r</td><td>rank </td></tr>
    <tr><td class="paramname">A</td><td>the matrix that will sotck the expanded representation </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">X</td><td>matrix to expand </td></tr>
    <tr><td class="paramname">ldx</td><td>leading dimension of X </td></tr>
    <tr><td class="paramname">K</td><td>stock the position of the blocks in A </td></tr>
    <tr><td class="paramname">M</td><td>permutation matrix </td></tr>
    <tr><td class="paramname">T</td><td>stock the operation done in the procedure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1508bd2e3ea0ef3b4e9022783dc871e7" name="a1508bd2e3ea0ef3b4e9022783dc871e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1508bd2e3ea0ef3b4e9022783dc871e7">&#9670;&nbsp;</a></span>Bruhat2EchelonPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bruhat2EchelonPermutation </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bruhat2EchelonPermutation (N,R,P,Q) Compute M such that LM or MU is in echelon form where L or U are factors of the Bruhat Rpresentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>permutation Matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>permutation Matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>output permutation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691fb5610440268a1977b4b3a2adcfc8" name="a691fb5610440268a1977b4b3a2adcfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691fb5610440268a1977b4b3a2adcfc8">&#9670;&nbsp;</a></span>productSSSxTS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void productSSSxTS </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the product of a quasi-separable matrix A, represented by a sequentially semi-separable generator, with a dense rectangular matrix B: <img class="formulaInl" alt="$ C \gets \alpha * A \times B + beta C $" src="form_94.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Fi</td><td>the base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the row and column dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>the column dimension of <code>B</code> and <code>C</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>the order of quasiseparability of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alpha</td><td>a scalar </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">D</td><td>an <img class="formulaInl" alt="$ N \times s$" src="form_95.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldd</td><td>leading dimension of <code>D</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>an <img class="formulaInl" alt="$ (N - s) \times s$" src="form_96.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldp</td><td>leading dimension of <code>P</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Q</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix where ls = (Ns)? Ns: s </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldq</td><td>leading dimension of <code>Q</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldr</td><td>leading dimension of <code>R</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">U</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldu</td><td>leading dimension of <code>U</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">V</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldv</td><td>leading dimension of <code>V</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">W</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldw</td><td>leading dimension of <code>W</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">B</td><td>an <img class="formulaInl" alt="$ N \times t$" src="form_99.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldb</td><td>leading dimension of <code>B</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">beta</td><td>scaling constant </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldc</td><td>leading dimension of <code>C</code> </td></tr>
  </table>
  </dd>
</dl>
<p>A = +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | D1 | U1V2 |U1W2V3|U1W2W3V4| ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P2Q1 | D2 | U2V3 | U2W3V4 | ... <br  />
 +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P3R2Q1 | P3Q2 | D3 | U3V4 | ... <br  />
 +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; |P4R3R2Q1|P4R3Q2| P4Q3 | D4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | ... | ... | ... | ... | ...</p>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000011">Bibliography:</a></b></dt><dd>S. Chandrasekaran et al. Fast Stable Solver for Sequentially Semi-separable Linear Systems of Equations. In : High Performance Computing  HiPC 2002. </dd></dl>

</div>
</div>
<a id="a75cbfc65f210580e0ef820d42774a046" name="a75cbfc65f210580e0ef820d42774a046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cbfc65f210580e0ef820d42774a046">&#9670;&nbsp;</a></span>SSSToDense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SSSToDense </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a quasi-separable matrix A from its SSS generators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Fi</td><td>the base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the row and column dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>the order of quasiseparability of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>an <img class="formulaInl" alt="$ (N - s) \times s$" src="form_96.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldp</td><td>leading dimension of <code>P</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Q</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix where ls = (Ns)? Ns: s </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldq</td><td>leading dimension of <code>Q</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldr</td><td>leading dimension of <code>R</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">U</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldu</td><td>leading dimension of <code>U</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">V</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldv</td><td>leading dimension of <code>V</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">W</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldw</td><td>leading dimension of <code>W</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">D</td><td>an <img class="formulaInl" alt="$ N \times s$" src="form_95.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldd</td><td>leading dimension of <code>D</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>the <img class="formulaInl" alt="$ N \times N $" src="form_100.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<p>A = +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | D1 | U1V2 |U1W2V3|U1W2W3V4| ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P2Q1 | D2 | U2V3 | U2W3V4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P3R2Q1 | P3Q2 | D3 | U3V4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; |P4R3R2Q1|P4R3Q2| P4Q3 | D4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | ... | ... | ... | ... | ...</p>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000012">Bibliography:</a></b></dt><dd>S. Chandrasekaran et al. Fast Stable Solver for Sequentially Semi-separable Linear Systems of Equations. In : High Performance Computing  HiPC 2002. </dd></dl>

</div>
</div>
<a id="a43ad974b5a7591c6956046d4473a30dc" name="a43ad974b5a7591c6956046d4473a30dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ad974b5a7591c6956046d4473a30dc">&#9670;&nbsp;</a></span>DenseToSSS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DenseToSSS </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes SSS generators for a quasi-separable matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Fi</td><td>the base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the row and column dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>the order of quasiseparability of <code>A</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P</td><td>an <img class="formulaInl" alt="$ (N - s) \times s$" src="form_96.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldp</td><td>leading dimension of <code>P</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> output matrix where ls = (Ns)? Ns: s </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldq</td><td>leading dimension of <code>Q</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">R</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldr</td><td>leading dimension of <code>R</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldu</td><td>leading dimension of <code>U</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>an <img class="formulaInl" alt="$ (N - ls) \times s$" src="form_97.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldv</td><td>leading dimension of <code>V</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">W</td><td>an <img class="formulaInl" alt="$ (N - s - ls) \times s$" src="form_98.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldw</td><td>leading dimension of <code>W</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">D</td><td>an <img class="formulaInl" alt="$ N \times s$" src="form_95.png"/> output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldd</td><td>leading dimension of <code>D</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>an <img class="formulaInl" alt="$ N \times N $" src="form_100.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<p>A = +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | D1 | U1V2 |U1W2V3|U1W2W3V4| ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P2Q1 | D2 | U2V3 | U2W3V4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | P3R2Q1 | P3Q2 | D3 | U3V4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; |P4R3R2Q1|P4R3Q2| P4Q3 | D4 | ... +-----&mdash;+---&mdash;+---&mdash;+-----&mdash;+-&mdash; | ... | ... | ... | ... | ... </p>

</div>
</div>
<a id="a3cd7b5a41ec8f1e7b722b50e8a836559" name="a3cd7b5a41ec8f1e7b722b50e8a836559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd7b5a41ec8f1e7b722b50e8a836559">&#9670;&nbsp;</a></span>LQUPtoInverseOfFullRankMinor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr LQUPtoInverseOfFullRankMinor </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>QtPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LQUPtoInverseOfFullRankMinor. </p>
<p >Suppose A has been factorized as L.Q.U.P, with rank r. Then Qt.A.Pt has an invertible leading principal r x r submatrix This procedure efficiently computes the inverse of this minor and puts it into X. </p><dl class="section note"><dt>Note</dt><dd>It changes the lower entries of A_factors in the process (NB: unless A was nonsingular and square)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>base field </td></tr>
    <tr><td class="paramname">rank</td><td>rank of the matrix. </td></tr>
    <tr><td class="paramname">A_factors</td><td>matrix containing the L and U entries of the factorization </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">QtPointer</td><td>theLQUP-&gt;getQ()-&gt;getPointer() (note: getQ returns Qt!) </td></tr>
    <tr><td class="paramname">X</td><td>desired location for output </td></tr>
    <tr><td class="paramname">ldx</td><td>leading dimension of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18ff1ad45afee814978cd0431442f11a" name="a18ff1ad45afee814978cd0431442f11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ff1ad45afee814978cd0431442f11a">&#9670;&nbsp;</a></span>RandomNullSpaceVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomNullSpaceVector </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_SIDE&#160;</td>
          <td class="paramname"><em>Side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>incX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve L X = B or X L = B in place. </p>
<p >L is M*M if Side == FFLAS::FflasLeft and N*N if Side == FFLAS::FflasRight, B is M*N. Only the R non trivial column of L are stored in the M*R matrix L Requirement : so that L could be expanded in-place Computes a vector of the Left/Right nullspace of the matrix A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>The computation domain </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Side</td><td>decides whether it computes the left (FflasLeft) or right (FflasRight) nullspace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>number of rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>input matrix of dimension M x N, A is modified to its LU version </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>output vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">incX</td><td>increment of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb90d1e5e309062288c2abd69877b58" name="adfb90d1e5e309062288c2abd69877b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb90d1e5e309062288c2abd69877b58">&#9670;&nbsp;</a></span>productBruhatxTS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void productBruhatxTS </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>Xu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NbBlocksU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Ku</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Tu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>Xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NbBlocksL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Kl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>Tl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>ML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of a left-triangular quasi-separable matrix A, represented by a compact Bruhat generator, with a dense rectangular matrix B: <img class="formulaInl" alt="$ C \gets A \times B + beta C $" src="form_101.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>the base field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the order of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>the order of quasiseparability of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>the number of pivots in the left-triangular par of the rank profile matrix of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>the number of columns of <code>B</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>the row indices of the pivots of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Q</td><td>the column indices of the pivots of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Xu</td><td>the compact storage of U: Du blocks in the first s rows, Su blocks in the last s rows </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldxu</td><td>the leading dimension of <code>Xu</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">NbBlocksU</td><td>the number of diagonal blocks in the compact storage of U </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ku</td><td>the list of starting column positions for each block of the storage of U </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Tu</td><td>the folding matrix for the compact storage of U: <img class="formulaInl" alt="$ Du + Tu  Su$" src="form_102.png"/> is in row echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Mu</td><td>a permutation matrix such that <img class="formulaInl" alt="$ Mu (Du + Tu  Su)$" src="form_103.png"/> is the U factor of the Bruhat generator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Xl</td><td>the compact storage of L: Dl blocks in the first s columns, Sl blocks in the last s columns </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldxl</td><td>the leading dimension of <code>Xl</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">NbBlocksL</td><td>the number of diagonal blocks in the compact storage of L </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Kl</td><td>the list of starting row positions for each block of the storage of L </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Tl</td><td>the folding matrix for the compact storage of L: <img class="formulaInl" alt="$ Dl + Sl  Tl $" src="form_104.png"/> is in column echelon form </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ml</td><td>a permutation matrix such that <img class="formulaInl" alt="$(Dl + Tl Sl) Ml $" src="form_105.png"/> is the L factor of the Bruhat generator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">B</td><td>an <img class="formulaInl" alt="$ N \times t$" src="form_99.png"/> dense matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldb</td><td>leading dimension of <code>B</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">beta</td><td>scaling constant </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>output matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ldc</td><td>leading dimension of <code>C</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000013">Bibliography:</a></b></dt><dd>Pernet C. and Storjohann A. <em><code>Time</code> and space efficient generators for quasiseparable matrices </em>, JSC (85), 2018, doi:10.1016/j.jsc.2017.07.010 </dd></dl>

</div>
</div>
<a id="a94502af7c734c7855d895308d26d1493" name="a94502af7c734c7855d895308d26d1493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94502af7c734c7855d895308d26d1493">&#9670;&nbsp;</a></span>buildMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr buildMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000018">Bug:</a></b></dt><dd>is this : </dd></dl>

</div>
</div>
<a id="ad9f31e0a202436eda09472c4363dfb69" name="ad9f31e0a202436eda09472c4363dfb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f31e0a202436eda09472c4363dfb69">&#9670;&nbsp;</a></span>fsytrf_UP_RPM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fsytrf_UP_RPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>Dinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>incDinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>BCThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >MathP &lt;-[ [ I ] x P1 | ] [ I_(N1+R2) ] [ P2^T ] | ] x [ P3^T ] [ -----------&mdash;|--&mdash; ] [ | Q2^T ]</p>
<p >Changing [ U1 V1 | E1 E21 E22 ] into [ U1 E11 E12 V1 E* E* ] [ 0 | L2 \ U2 V21 V22 ] [ U4 V41 0 V42 V43 ] [ 0 | M2 0 0 ] [ U3 0 0 V3 ] [ ---&mdash;|-------------&mdash; ] [ 0 0 0 ] [ 0 | H1 H21 H22 ] [ 0 | U3 V3 ] [ 0 | 0 ] where U4 is the 2R2 x 2R2 matrix formed by interleaving U2, L2^T and H1</p>

</div>
</div>
<a id="a6e7e49bbe7a2dea84f08ae1fe0e91bcc" name="a6e7e49bbe7a2dea84f08ae1fe0e91bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7e49bbe7a2dea84f08ae1fe0e91bcc">&#9670;&nbsp;</a></span>LUdivine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LUdivine </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_TRANSPOSE&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK::FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>cutoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>std::swap ? </dd></dl>

</div>
</div>
<a id="ac5f4db92c513a15a5079ea1cfd609960" name="ac5f4db92c513a15a5079ea1cfd609960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4db92c513a15a5079ea1cfd609960">&#9670;&nbsp;</a></span>composePermutationsLLL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void composePermutationsLLL </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in P1 as a LAPACK permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">P1</td><td>a LAPACK permutation of size N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P2</td><td>a LAPACK permutation of size N-R </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e7889cb2cdf1eb12d30144155f364ac" name="a7e7889cb2cdf1eb12d30144155f364ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7889cb2cdf1eb12d30144155f364ac">&#9670;&nbsp;</a></span>composePermutationsLLM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void composePermutationsLLM </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>MathP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in MathP as a MathPermutation format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>a MathPermutation of size N </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1</td><td>a LAPACK permutation of size N </td></tr>
    <tr><td class="paramname">P2</td><td>a LAPACK permutation of size N-R </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73a966205b9cc62fda547fd31e30da56" name="a73a966205b9cc62fda547fd31e30da56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a966205b9cc62fda547fd31e30da56">&#9670;&nbsp;</a></span>composePermutationsMLM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void composePermutationsMLM </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>MathP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes MathP1 x Diag (I_R, P2) where MathP1 is a MathPermutation and P2 a LAPACK permutation and store the result in MathP1 as a MathPermutation format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MathP1</td><td>a MathPermutation of size N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P2</td><td>a LAPACK permutation of size N-R </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac202d94135e30327511e47311647f14a" name="ac202d94135e30327511e47311647f14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac202d94135e30327511e47311647f14a">&#9670;&nbsp;</a></span>PLUQRRRGen_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; * PLUQRRRGen_rec </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RRR Generator recursive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">N</td><td>size of A </td></tr>
    <tr><td class="paramname">s</td><td>quasiseparability order </td></tr>
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">lda</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root of the RRR representation of A </dd></dl>

</div>
</div>
<a id="a6530e127d526df2d1721475a47874eef" name="a6530e127d526df2d1721475a47874eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6530e127d526df2d1721475a47874eef">&#9670;&nbsp;</a></span>PLUQRRRGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; * PLUQRRRGen </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RRR Generator API. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">N</td><td>size of A </td></tr>
    <tr><td class="paramname">s</td><td>order of quasiseparability </td></tr>
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">lda</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the RRR representation of A </dd></dl>

</div>
</div>
<a id="abf47737c405f93df531d8ca134b74354" name="abf47737c405f93df531d8ca134b74354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf47737c405f93df531d8ca134b74354">&#9670;&nbsp;</a></span>RRRExpandrec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRExpandrec </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 4) Compute the dense matrix of RRR(A) in B recursive part </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">nodeA</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">ldb</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ac8b66d78d34e86ed061c7dc54be29b" name="a8ac8b66d78d34e86ed061c7dc54be29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac8b66d78d34e86ed061c7dc54be29b">&#9670;&nbsp;</a></span>RRRExpand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRExpand </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>RRRA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 4) Compute the dense matrix of RRR(A) in B </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">RRRA</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">ldb</td><td><br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb26e7290ab3774a597b9560d57edf11" name="aeb26e7290ab3774a597b9560d57edf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb26e7290ab3774a597b9560d57edf11">&#9670;&nbsp;</a></span>RRxRR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRxRR </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 5) multiplies two matrices stored as rank revealing factorization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">r_A</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">r_b</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">LA</td><td>size m*r_A </td></tr>
    <tr><td class="paramname">UA</td><td>size r_A*k </td></tr>
    <tr><td class="paramname">LB</td><td>size k*r_B </td></tr>
    <tr><td class="paramname">UB</td><td>size r_B*n </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramname">ldb</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">ldc</td><td>leading dimension of C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa62160dad26925283196e9de5917abf" name="aaa62160dad26925283196e9de5917abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa62160dad26925283196e9de5917abf">&#9670;&nbsp;</a></span>RRaddRR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRaddRR </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 6) add two matrices stored as rank revealing factorization </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">r_A</td><td></td></tr>
    <tr><td class="paramname">r_b</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">LA</td><td>size (m*r_A) transpose </td></tr>
    <tr><td class="paramname">UA</td><td>size r_A*n </td></tr>
    <tr><td class="paramname">LB</td><td>size (m*r_b) transpose </td></tr>
    <tr><td class="paramname">UB</td><td>size r_b*n </td></tr>
    <tr><td class="paramname">ldLA</td><td>leading dimension of LA </td></tr>
    <tr><td class="paramname">ldUA</td><td>leading dimension of UA </td></tr>
    <tr><td class="paramname">ldLB</td><td>leading dimension of LB </td></tr>
    <tr><td class="paramname">ldUB</td><td>leading dimension of UB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5cec2abe2f1d191ede7ff60efe7f585" name="ab5cec2abe2f1d191ede7ff60efe7f585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cec2abe2f1d191ede7ff60efe7f585">&#9670;&nbsp;</a></span>RRRaddRR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRaddRR </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 7) Adds a quasiseparable matrix in RRR representation and a rank revealing factorization. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">s</td><td>order of quasiseparability of A </td></tr>
    <tr><td class="paramname">r_b</td><td>rank of b </td></tr>
    <tr><td class="paramname">n</td><td>dimension of A and B </td></tr>
    <tr><td class="paramname">A</td><td>size n*n in RRR representation </td></tr>
    <tr><td class="paramname">LB</td><td>size n*r_b </td></tr>
    <tr><td class="paramname">UB</td><td>size r_b*n <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3056d72f6cee15adc4a15d7e388161d1" name="a3056d72f6cee15adc4a15d7e388161d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3056d72f6cee15adc4a15d7e388161d1">&#9670;&nbsp;</a></span>RRRxTSrec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRxTSrec </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_node.html">Node</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 8) Multiplies a quasiseparable matric in RRR representation with a tall and skinny matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">s</td><td>order of quasisep of A </td></tr>
    <tr><td class="paramname">t</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">A</td><td>size n*n in RRR representation </td></tr>
    <tr><td class="paramname">B</td><td>size n*t </td></tr>
    <tr><td class="paramname">ldB</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">C</td><td>size n*t </td></tr>
    <tr><td class="paramname">ldC</td><td>leading dimension of C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e640c8922617688cb055a051e4d6951" name="a1e640c8922617688cb055a051e4d6951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e640c8922617688cb055a051e4d6951">&#9670;&nbsp;</a></span>RRRxTS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRxTS </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 8) Multiplies a quasiseparable matric in RRR representation with a tall and skinny matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">s</td><td>order of quasisep of A </td></tr>
    <tr><td class="paramname">t</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">A</td><td>size n*n in RRR representation </td></tr>
    <tr><td class="paramname">B</td><td>size n*t </td></tr>
    <tr><td class="paramname">ldB</td><td>leading dimension of B </td></tr>
    <tr><td class="paramname">C</td><td>size n*t </td></tr>
    <tr><td class="paramname">ldC</td><td>leading dimension of C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0bc7eac6d6c3e1c174ebda55485868b" name="ad0bc7eac6d6c3e1c174ebda55485868b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bc7eac6d6c3e1c174ebda55485868b">&#9670;&nbsp;</a></span>RRRxRR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRxRR </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::ConstElement_ptr&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>LC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldLC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>UC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ldUC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(algo 9) Multiplies a QS matrix in RRR representation with a rank revealing factorization Compute C = A*B </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">s</td><td>order of QS of A </td></tr>
    <tr><td class="paramname">n</td><td><br  />
 </td></tr>
    <tr><td class="paramname">r_b</td><td>rank of B </td></tr>
    <tr><td class="paramname">m</td><td><br  />
 </td></tr>
    <tr><td class="paramname">A</td><td>size n*n in a RRR representation <br  />
 </td></tr>
    <tr><td class="paramname">LB</td><td>size n*r_b </td></tr>
    <tr><td class="paramname">UB</td><td>size r_b*m </td></tr>
    <tr><td class="paramname">ldLB</td><td>leading dimension of LB </td></tr>
    <tr><td class="paramname">ldUB</td><td>leading dimension of UB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc8bc54c52fd8eaccb1e5692b5bf6fdb" name="afc8bc54c52fd8eaccb1e5692b5bf6fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8bc54c52fd8eaccb1e5692b5bf6fdb">&#9670;&nbsp;</a></span>RRRxRRR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRxRRR </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplies two QS matrices (algo 10) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">s</td><td>order of QS of A </td></tr>
    <tr><td class="paramname">t</td><td>order of QS of B </td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">A</td><td>size n*n </td></tr>
    <tr><td class="paramname">B</td><td>size n*n </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81631373e30bf744d23506adf9f1e732" name="a81631373e30bf744d23506adf9f1e732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81631373e30bf744d23506adf9f1e732">&#9670;&nbsp;</a></span>RRRinvert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RRRinvert </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>Fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_f_p_a_c_k_1_1_r_r_rrep.html">RRRrep</a>&lt; Field &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse in RRR representation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Field</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fi</td><td></td></tr>
    <tr><td class="paramname">A</td><td>in RRR representation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c6d819cd3915b3eae46791ee3c2ba7b" name="a5c6d819cd3915b3eae46791ee3c2ba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6d819cd3915b3eae46791ee3c2ba7b">&#9670;&nbsp;</a></span>NonZeroRandomMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr NonZeroRandomMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random non-zero Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries, and at least one of them is non zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a84356fd5ca2843795970e30c7d2af66b" name="a84356fd5ca2843795970e30c7d2af66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84356fd5ca2843795970e30c7d2af66b">&#9670;&nbsp;</a></span>NonZeroRandomMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr NonZeroRandomMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random non-zero Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries, and at least one of them is non zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a584460ea638cb2942b89ef28dd58c489" name="a584460ea638cb2942b89ef28dd58c489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584460ea638cb2942b89ef28dd58c489">&#9670;&nbsp;</a></span>RandomMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="ab288de7b77ff71e4d05930e27486bf52" name="ab288de7b77ff71e4d05930e27486bf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab288de7b77ff71e4d05930e27486bf52">&#9670;&nbsp;</a></span>RandomMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a040b5ff1e71e0e518f7d7a5624245501" name="a040b5ff1e71e0e518f7d7a5624245501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040b5ff1e71e0e518f7d7a5624245501">&#9670;&nbsp;</a></span>RandomTriangularMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomTriangularMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>UpLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonsingular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Triangular Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> triangular matrix with random entries. The <code>UpLo</code> parameter defines wether it is upper or lower triangular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>whether <code>A</code> is upper or lower triangular </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a8389197600198a0d756662596b59268a" name="a8389197600198a0d756662596b59268a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8389197600198a0d756662596b59268a">&#9670;&nbsp;</a></span>RandomTriangularMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomTriangularMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_UPLO&#160;</td>
          <td class="paramname"><em>UpLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFLAS::FFLAS_DIAG&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonsingular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Triangular Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> triangular matrix with random entries. The <code>UpLo</code> parameter defines wether it is upper or lower triangular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpLo</td><td>whether <code>A</code> is upper or lower triangular </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a9b941fefbfda9aaf0272d5b1476da563" name="a9b941fefbfda9aaf0272d5b1476da563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b941fefbfda9aaf0272d5b1476da563">&#9670;&nbsp;</a></span>RandomSymmetricMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonsingular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Symmetric Matrix. </p>
<p >Creates a <code>m</code> x <code>n</code> triangular matrix with random entries. The <code>UpLo</code> parameter defines wether it is upper or lower triangular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>order of <code>A</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a317eca01fd2d55e857e5eeb37698eb0a" name="a317eca01fd2d55e857e5eeb37698eb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317eca01fd2d55e857e5eeb37698eb0a">&#9670;&nbsp;</a></span>RandomMatrixWithRank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRank </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank. </p>
<p >Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="af772df4d24c94818f611bc842e44b569" name="af772df4d24c94818f611bc842e44b569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af772df4d24c94818f611bc842e44b569">&#9670;&nbsp;</a></span>RandomMatrixWithRank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRank </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank. </p>
<p >Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="ae3f4cadf20c5e40912db77e34a65b318" name="ae3f4cadf20c5e40912db77e34a65b318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4cadf20c5e40912db77e34a65b318">&#9670;&nbsp;</a></span>RandomIndexSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t * RandomIndexSubset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick uniformly at random a sequence of <code>R</code> distinct elements from the set <img class="formulaInl" alt="$ \{0,\dots, N-1\}$" src="form_106.png"/> using Knuth's shuffle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the cardinality of the sampling set </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">R</td><td>the number of elements to sample </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>the output sequence (pre-allocated to at least R indices) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae52a08d2b41e281e34d5b41496bfddf8" name="ae52a08d2b41e281e34d5b41496bfddf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52a08d2b41e281e34d5b41496bfddf8">&#9670;&nbsp;</a></span>RandomPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t * RandomPermutation </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick uniformly at random a permutation of size <code>N</code> stored in LAPACK format using Knuth's shuffle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>the length of the permutation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>the output permutation (pre-allocated to at least N indices) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7d6ef645c3268a94d70c2e5d4f0ca8e" name="ad7d6ef645c3268a94d70c2e5d4f0ca8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d6ef645c3268a94d70c2e5d4f0ca8e">&#9670;&nbsp;</a></span>RandomRankProfileMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RandomRankProfileMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick uniformly at random an R-subpermutation of dimension <code>M</code> x <code>N</code> : a matrix with only R non-zeros equal to one, in a random rook placement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rows</td><td>the row position of each non zero element (pre-allocated) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cols</td><td>the column position of each non zero element (pre-allocated) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1370fe044bc6259c148a1d9ca84cc970" name="a1370fe044bc6259c148a1d9ca84cc970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1370fe044bc6259c148a1d9ca84cc970">&#9670;&nbsp;</a></span>RandomSymmetricRankProfileMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RandomSymmetricRankProfileMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick uniformly at random a symmetric R-subpermutation of dimension <code>N</code> x <code>N</code> : a symmetric matrix with only R non-zeros, all equal to one, in a random rook placement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>matrix order </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rows</td><td>the row position of each non zero element (pre-allocated) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cols</td><td>the column position of each non zero element (pre-allocated) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ff744c6fc1bf46097fed4905b407d02" name="a2ff744c6fc1bf46097fed4905b407d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff744c6fc1bf46097fed4905b407d02">&#9670;&nbsp;</a></span>RandomMatrixWithRankandRPM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRankandRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>RRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>CRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank and rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">RRP</td><td>the R dimensional array with row positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">CRP</td><td>the R dimensional array with column positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a323f761ba30a690239450b7b6ede1c7e" name="a323f761ba30a690239450b7b6ede1c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323f761ba30a690239450b7b6ede1c7e">&#9670;&nbsp;</a></span>RandomMatrixWithRankandRPM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRankandRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>RRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>CRP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank and rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">RRP</td><td>the R dimensional array with row positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">CRP</td><td>the R dimensional array with column positions of the rank profile matrix' pivots </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="aaf60dc80006757b600bd802746ab8bb9" name="aaf60dc80006757b600bd802746ab8bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf60dc80006757b600bd802746ab8bb9">&#9670;&nbsp;</a></span>RandomSymmetricMatrixWithRankandRPM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomSymmetricMatrixWithRankandRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>RRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>CRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Symmetric Matrix with prescribed rank and rank profile matrix Creates an <code>n</code> x <code>n</code> symmetric matrix with random entries and rank <code>r</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">n</td><td>order of <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">RRP</td><td>the R dimensional array with row positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">CRP</td><td>the R dimensional array with column positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="ae67d59bb20ce739539b506708a469d09" name="ae67d59bb20ce739539b506708a469d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67d59bb20ce739539b506708a469d09">&#9670;&nbsp;</a></span>RandomSymmetricMatrixWithRankandRPM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomSymmetricMatrixWithRankandRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>RRP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>CRP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Symmetric Matrix with prescribed rank and rank profile matrix Creates an <code>n</code> x <code>n</code> symmetric matrix with random entries and rank <code>r</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">n</td><td>order of <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">RRP</td><td>the R dimensional array with row positions of the rank profile matrix' pivots </td></tr>
    <tr><td class="paramname">CRP</td><td>the R dimensional array with column positions of the rank profile matrix' pivots </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a4d5df400db47b16c9ebd532f30a0da61" name="a4d5df400db47b16c9ebd532f30a0da61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5df400db47b16c9ebd532f30a0da61">&#9670;&nbsp;</a></span>RandomMatrixWithRankandRandomRPM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRankandRandomRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank, with random rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a15d159d4717933325a35cf6723b65ce2" name="a15d159d4717933325a35cf6723b65ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d159d4717933325a35cf6723b65ce2">&#9670;&nbsp;</a></span>RandomMatrixWithRankandRandomRPM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithRankandRandomRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed rank, with random rank profile matrix Creates an <code>m</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in <code>A</code> </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of the matrix to build </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>m</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a2738e3a50b07da4949a76d1df34a3e19" name="a2738e3a50b07da4949a76d1df34a3e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2738e3a50b07da4949a76d1df34a3e19">&#9670;&nbsp;</a></span>RandomSymmetricMatrixWithRankandRandomRPM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomSymmetricMatrixWithRankandRandomRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Symmetric Matrix with prescribed rank, with random rank profile matrix Creates an <code>n</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">n</td><td>order of <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
    <tr><td class="paramname">G</td><td>a random iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="ae85a5a12084e3c87e0a65fe9717fdac8" name="ae85a5a12084e3c87e0a65fe9717fdac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85a5a12084e3c87e0a65fe9717fdac8">&#9670;&nbsp;</a></span>RandomSymmetricMatrixWithRankandRandomRPM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomSymmetricMatrixWithRankandRandomRPM </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Symmetric Matrix with prescribed rank, with random rank profile matrix Creates an <code>n</code> x <code>n</code> matrix with random entries, rank <code>r</code> and with a rank profile matrix chosen uniformly at random. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">n</td><td>order of <code>A</code> </td></tr>
    <tr><td class="paramname">r</td><td>rank of <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a80b9f48168255e0dc0b33dc1977f1d01" name="a80b9f48168255e0dc0b33dc1977f1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b9f48168255e0dc0b33dc1977f1d01">&#9670;&nbsp;</a></span>RandomMatrixWithDet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithDet </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed det. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">d</td><td>the prescribed value for the determinant of A </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix to be generated (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
<a id="a98e7076880d54bab70d8c243cddc959c" name="a98e7076880d54bab70d8c243cddc959c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e7076880d54bab70d8c243cddc959c">&#9670;&nbsp;</a></span>RandomMatrixWithDet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Field::Element_ptr RandomMatrixWithDet </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Field::Element&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandIter &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Random Matrix with prescribed det. </p>
<p >Creates a <code>m</code> x <code>n</code> matrix with random entries and rank <code>r</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>field </td></tr>
    <tr><td class="paramname">d</td><td>the prescribed value for the determinant of A </td></tr>
    <tr><td class="paramname">n</td><td>number of cols in <code>A</code> </td></tr>
    <tr><td class="paramname">A</td><td>the matrix to be generated (preallocated to at least <code>n</code> x <code>lda</code> field elements) </td></tr>
    <tr><td class="paramname">lda</td><td>leading dimension of <code>A</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>A</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 3 2025 16:14:32 for FFLAS-FFPACK by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
