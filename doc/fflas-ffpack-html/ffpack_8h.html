<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFLAS-FFPACK: ffpack.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FFLAS-FFPACK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_eac799a5944e2226b86d15a6d06c7d67.html">fflas-ffpack</a></li><li class="navelem"><a class="el" href="dir_3f4dc184899094e062ff9eb0d20a1f3e.html">ffpack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ffpack.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Set of elimination based routines for dense linear algebra.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;givaro/givpoly1.h&quot;</code><br />
<code>#include &lt;<a class="el" href="fflas-ffpack-config_8h.html">fflas-ffpack/fflas-ffpack-config.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="fflas_8h.html">fflas-ffpack/fflas/fflas.h</a>&quot;</code><br />
<code>#include &quot;fflas-ffpack/fflas/fflas_helpers.inl&quot;</code><br />
<code>#include &lt;list&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;fflas-ffpack/checkers/checkers_ffpack.h&quot;</code><br />
<code>#include &quot;ffpack_fgesv.inl&quot;</code><br />
<code>#include &quot;ffpack_fgetrs.inl&quot;</code><br />
<code>#include &quot;fflas-ffpack/checkers/checkers_ffpack.inl&quot;</code><br />
<code>#include &quot;ffpack_pluq.inl&quot;</code><br />
<code>#include &quot;ffpack_pluq_mp.inl&quot;</code><br />
<code>#include &quot;ffpack_ppluq.inl&quot;</code><br />
<code>#include &quot;ffpack_ludivine.inl&quot;</code><br />
<code>#include &quot;ffpack_ludivine_mp.inl&quot;</code><br />
<code>#include &quot;ffpack_echelonforms.inl&quot;</code><br />
<code>#include &quot;ffpack_fsytrf.inl&quot;</code><br />
<code>#include &quot;ffpack_invert.inl&quot;</code><br />
<code>#include &quot;ffpack_ftrtr.inl&quot;</code><br />
<code>#include &quot;ffpack_ftrstr.inl&quot;</code><br />
<code>#include &quot;ffpack_ftrssyr2k.inl&quot;</code><br />
<code>#include &quot;ffpack_charpoly_kglu.inl&quot;</code><br />
<code>#include &quot;ffpack_charpoly_kgfast.inl&quot;</code><br />
<code>#include &quot;ffpack_charpoly_kgfastgeneralized.inl&quot;</code><br />
<code>#include &quot;ffpack_charpoly_danilevski.inl&quot;</code><br />
<code>#include &quot;ffpack_charpoly.inl&quot;</code><br />
<code>#include &quot;ffpack_frobenius.inl&quot;</code><br />
<code>#include &quot;ffpack_minpoly.inl&quot;</code><br />
<code>#include &quot;ffpack_krylovelim.inl&quot;</code><br />
<code>#include &quot;ffpack_permutation.inl&quot;</code><br />
<code>#include &quot;ffpack_rankprofiles.inl&quot;</code><br />
<code>#include &quot;ffpack_det_mp.inl&quot;</code><br />
<code>#include &quot;ffpack_bruhatgen.inl&quot;</code><br />
<code>#include &quot;ffpack_sss.inl&quot;</code><br />
<code>#include &quot;ffpack.inl&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_f_f_p_a_c_k"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html">FFPACK</a></td></tr>
<tr class="memdesc:namespace_f_f_p_a_c_k"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>F</b>inite <b>F</b>ield <b>PACK</b> Set of elimination based routines for dense linear algebra. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a213f24b93e481e4e7efd899e59a2b17e"><td class="memItemLeft" align="right" valign="top"><a id="a213f24b93e481e4e7efd899e59a2b17e" name="a213f24b93e481e4e7efd899e59a2b17e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LAPACKPerm2MathPerm</b> (size_t *MathP, const size_t *LapackP, const size_t N)</td></tr>
<tr class="memdesc:a213f24b93e481e4e7efd899e59a2b17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of a permutation from LAPACK format to Math format. <br /></td></tr>
<tr class="separator:a213f24b93e481e4e7efd899e59a2b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4320d92abd30637ce5b26c50f989b11"><td class="memItemLeft" align="right" valign="top"><a id="aa4320d92abd30637ce5b26c50f989b11" name="aa4320d92abd30637ce5b26c50f989b11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MathPerm2LAPACKPerm</b> (size_t *LapackP, const size_t *MathP, const size_t N)</td></tr>
<tr class="memdesc:aa4320d92abd30637ce5b26c50f989b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of a permutation from Maths format to LAPACK format. <br /></td></tr>
<tr class="separator:aa4320d92abd30637ce5b26c50f989b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1cddd27a131dabda817df0ec0b7177"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a1b1cddd27a131dabda817df0ec0b7177"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1b1cddd27a131dabda817df0ec0b7177">applyP</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const FFLAS::FFLAS_TRANSPOSE Trans, const size_t M, const size_t ibeg, const size_t iend, typename Field::Element_ptr A, const size_t lda, const size_t *P)</td></tr>
<tr class="memdesc:a1b1cddd27a131dabda817df0ec0b7177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes P1 x Diag (I_R, P2) where P1 is a LAPACK and P2 a LAPACK permutation and store the result in P1 as a LAPACK permutation.  <a href="namespace_f_f_p_a_c_k.html#a1b1cddd27a131dabda817df0ec0b7177">More...</a><br /></td></tr>
<tr class="separator:a1b1cddd27a131dabda817df0ec0b7177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a2e0a8fba965dfc44b5ef07ab856ed825">MonotonicApplyP</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const FFLAS::FFLAS_TRANSPOSE Trans, const size_t M, const size_t ibeg, const size_t iend, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t R)</td></tr>
<tr class="memdesc:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a R-monotonically increasing permutation P, to the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a2e0a8fba965dfc44b5ef07ab856ed825">More...</a><br /></td></tr>
<tr class="separator:a2e0a8fba965dfc44b5ef07ab856ed825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a43b157c8206491f4c4e5337a3f9423"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a0a43b157c8206491f4c4e5337a3f9423"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a0a43b157c8206491f4c4e5337a3f9423">fgetrs</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t R, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t *Q, typename Field::Element_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a0a43b157c8206491f4c4e5337a3f9423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system <img class="formulaInl" alt="$A X = B$" src="form_78.png"/> or <img class="formulaInl" alt="$X A = B$" src="form_79.png"/>.  <a href="namespace_f_f_p_a_c_k.html#a0a43b157c8206491f4c4e5337a3f9423">More...</a><br /></td></tr>
<tr class="separator:a0a43b157c8206491f4c4e5337a3f9423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a19f62816af5c3957e5d8dcd60eed1f3f">fgetrs</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t NRHS, const size_t R, typename Field::Element_ptr A, const size_t lda, const size_t *P, const size_t *Q, typename Field::Element_ptr X, const size_t ldx, typename Field::ConstElement_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system A X = B or X A = B.  <a href="namespace_f_f_p_a_c_k.html#a19f62816af5c3957e5d8dcd60eed1f3f">More...</a><br /></td></tr>
<tr class="separator:a19f62816af5c3957e5d8dcd60eed1f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f26909f63a855dfeefee2d55dae1d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ade4f26909f63a855dfeefee2d55dae1d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ade4f26909f63a855dfeefee2d55dae1d">fgesv</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:ade4f26909f63a855dfeefee2d55dae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square system solver.  <a href="namespace_f_f_p_a_c_k.html#ade4f26909f63a855dfeefee2d55dae1d">More...</a><br /></td></tr>
<tr class="separator:ade4f26909f63a855dfeefee2d55dae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a68ff465a100ffa4c64abd6be721c3d3d">fgesv</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, const size_t NRHS, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, typename Field::ConstElement_ptr B, const size_t ldb, int *info)</td></tr>
<tr class="memdesc:a68ff465a100ffa4c64abd6be721c3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangular system solver.  <a href="namespace_f_f_p_a_c_k.html#a68ff465a100ffa4c64abd6be721c3d3d">More...</a><br /></td></tr>
<tr class="separator:a68ff465a100ffa4c64abd6be721c3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae8ebbf599c6c93aa1689edd3763b1887">ftrtri</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG Diag, const size_t N, typename Field::Element_ptr A, const size_t lda, const size_t threshold=__FFLASFFPACK_FTRTRI_THRESHOLD)</td></tr>
<tr class="memdesc:ae8ebbf599c6c93aa1689edd3763b1887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a triangular matrix.  <a href="namespace_f_f_p_a_c_k.html#ae8ebbf599c6c93aa1689edd3763b1887">More...</a><br /></td></tr>
<tr class="separator:ae8ebbf599c6c93aa1689edd3763b1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab7c38fdc258c7071c3d4ff39ee419a9c">ftrtrm</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE side, const FFLAS::FFLAS_DIAG diag, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of two triangular matrices of opposite shape.  <a href="namespace_f_f_p_a_c_k.html#ab7c38fdc258c7071c3d4ff39ee419a9c">More...</a><br /></td></tr>
<tr class="separator:ab7c38fdc258c7071c3d4ff39ee419a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adece02815384390d9693661abee012ed"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:adece02815384390d9693661abee012ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#adece02815384390d9693661abee012ed">ftrstr</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE side, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diagA, const FFLAS::FFLAS_DIAG diagB, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, const size_t threshold=64)</td></tr>
<tr class="memdesc:adece02815384390d9693661abee012ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular system with a triangular right hand side of the same shape.  <a href="namespace_f_f_p_a_c_k.html#adece02815384390d9693661abee012ed">More...</a><br /></td></tr>
<tr class="separator:adece02815384390d9693661abee012ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72941c6ae84659f44db2b096458bda56"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a72941c6ae84659f44db2b096458bda56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a72941c6ae84659f44db2b096458bda56">ftrssyr2k</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diagA, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr B, const size_t ldb, const size_t threshold=64)</td></tr>
<tr class="memdesc:a72941c6ae84659f44db2b096458bda56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular system in a symmetric sum: find B upper/lower triangular such that A^T B + B^T A = C where C is symmetric.  <a href="namespace_f_f_p_a_c_k.html#a72941c6ae84659f44db2b096458bda56">More...</a><br /></td></tr>
<tr class="separator:a72941c6ae84659f44db2b096458bda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea15a71392b8116270ba58d44f99b0a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:abea15a71392b8116270ba58d44f99b0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#abea15a71392b8116270ba58d44f99b0a">fsytrf</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO UpLo, const size_t N, typename Field::Element_ptr A, const size_t lda, const size_t threshold=__FFLASFFPACK_FSYTRF_THRESHOLD)</td></tr>
<tr class="memdesc:abea15a71392b8116270ba58d44f99b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular factorization of symmetric matrices.  <a href="namespace_f_f_p_a_c_k.html#abea15a71392b8116270ba58d44f99b0a">More...</a><br /></td></tr>
<tr class="separator:abea15a71392b8116270ba58d44f99b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03905818bbd609ea0318414856d20374"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a03905818bbd609ea0318414856d20374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a03905818bbd609ea0318414856d20374">fsytrf_nonunit</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO UpLo, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr D, const size_t incD, const size_t threshold=__FFLASFFPACK_FSYTRF_THRESHOLD)</td></tr>
<tr class="memdesc:a03905818bbd609ea0318414856d20374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangular factorization of symmetric matrices.  <a href="namespace_f_f_p_a_c_k.html#a03905818bbd609ea0318414856d20374">More...</a><br /></td></tr>
<tr class="separator:a03905818bbd609ea0318414856d20374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f90809584dae59b27fec78c77e927"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a834f90809584dae59b27fec78c77e927"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a834f90809584dae59b27fec78c77e927">PLUQ</a> (const Field &amp;F, const FFLAS::FFLAS_DIAG Diag, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Q)</td></tr>
<tr class="memdesc:a834f90809584dae59b27fec78c77e927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a PLUQ factorization of the given matrix; such that A=PLUQ.  <a href="namespace_f_f_p_a_c_k.html#a834f90809584dae59b27fec78c77e927">More...</a><br /></td></tr>
<tr class="separator:a834f90809584dae59b27fec78c77e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8167a1477d10a7367cce30923281b0fe"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8167a1477d10a7367cce30923281b0fe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8167a1477d10a7367cce30923281b0fe">LUdivine</a> (const Field &amp;F, const FFLAS::FFLAS_DIAG Diag, const FFLAS::FFLAS_TRANSPOSE trans, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive, const size_t cutoff=__FFLASFFPACK_LUDIVINE_THRESHOLD)</td></tr>
<tr class="memdesc:a8167a1477d10a7367cce30923281b0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CUP or PLE factorization of the given matrix.  <a href="namespace_f_f_p_a_c_k.html#a8167a1477d10a7367cce30923281b0fe">More...</a><br /></td></tr>
<tr class="separator:a8167a1477d10a7367cce30923281b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a150d6acb28e77ec56949bf99dd8e3e73">ColumnEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a150d6acb28e77ec56949bf99dd8e3e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Column Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#a150d6acb28e77ec56949bf99dd8e3e73">More...</a><br /></td></tr>
<tr class="separator:a150d6acb28e77ec56949bf99dd8e3e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a8223494b06149b4db058c56b25083"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa5a8223494b06149b4db058c56b25083"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aa5a8223494b06149b4db058c56b25083">RowEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aa5a8223494b06149b4db058c56b25083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Row Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#aa5a8223494b06149b4db058c56b25083">More...</a><br /></td></tr>
<tr class="separator:aa5a8223494b06149b4db058c56b25083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a813e34d18a3de299b26bd9de2c8e4b4d">ReducedColumnEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Reduced Column Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#a813e34d18a3de299b26bd9de2c8e4b4d">More...</a><br /></td></tr>
<tr class="separator:a813e34d18a3de299b26bd9de2c8e4b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab9aba43cbf35752df1c5c5f24193fb2a">ReducedRowEchelonForm</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Qt, const bool transform=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Reduced Row Echelon form of the input matrix in-place.  <a href="namespace_f_f_p_a_c_k.html#ab9aba43cbf35752df1c5c5f24193fb2a">More...</a><br /></td></tr>
<tr class="separator:ab9aba43cbf35752df1c5c5f24193fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf910bfffdd3f3f71bff7b29ae238e6"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8cf910bfffdd3f3f71bff7b29ae238e6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ffpack_8h.html#a8cf910bfffdd3f3f71bff7b29ae238e6">GaussJordan</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, const size_t colbeg, const size_t rowbeg, const size_t colsize, size_t *P, size_t *Q, const FFPACK::FFPACK_LU_TAG LuTag)</td></tr>
<tr class="memdesc:a8cf910bfffdd3f3f71bff7b29ae238e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss-Jordan algorithm computing the Reduced Row echelon form and its transform matrix.  <a href="ffpack_8h.html#a8cf910bfffdd3f3f71bff7b29ae238e6">More...</a><br /></td></tr>
<tr class="separator:a8cf910bfffdd3f3f71bff7b29ae238e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62197ee1bbc40b25843361f574bf9748"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a62197ee1bbc40b25843361f574bf9748"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a62197ee1bbc40b25843361f574bf9748">Invert</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, int &amp;nullity)</td></tr>
<tr class="memdesc:a62197ee1bbc40b25843361f574bf9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix in place or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a62197ee1bbc40b25843361f574bf9748">More...</a><br /></td></tr>
<tr class="separator:a62197ee1bbc40b25843361f574bf9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4336928c74f094a5ddebcec18bb17bb5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4336928c74f094a5ddebcec18bb17bb5"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4336928c74f094a5ddebcec18bb17bb5">Invert</a> (const Field &amp;F, const size_t M, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, int &amp;nullity)</td></tr>
<tr class="memdesc:a4336928c74f094a5ddebcec18bb17bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a4336928c74f094a5ddebcec18bb17bb5">More...</a><br /></td></tr>
<tr class="separator:a4336928c74f094a5ddebcec18bb17bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681c044c0d4533c4387ef15e867fd886"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a681c044c0d4533c4387ef15e867fd886"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a681c044c0d4533c4387ef15e867fd886">Invert2</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t ldx, int &amp;nullity)</td></tr>
<tr class="memdesc:a681c044c0d4533c4387ef15e867fd886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the given matrix or computes its nullity if it is singular.  <a href="namespace_f_f_p_a_c_k.html#a681c044c0d4533c4387ef15e867fd886">More...</a><br /></td></tr>
<tr class="separator:a681c044c0d4533c4387ef15e867fd886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; typename PolRing::Element &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1d3e9f9fe5ff9d62e286be6eda2b01bf">CharPoly</a> (const PolRing &amp;R, std::list&lt; typename PolRing::Element &gt; &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, typename PolRing::Domain_t::RandIter &amp;G, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a1d3e9f9fe5ff9d62e286be6eda2b01bf">More...</a><br /></td></tr>
<tr class="separator:a1d3e9f9fe5ff9d62e286be6eda2b01bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memTemplItemLeft" align="right" valign="top">PolRing::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#af12460cbc0f7735e5c6ac5eaba73a17b">CharPoly</a> (const PolRing &amp;R, typename PolRing::Element &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, typename PolRing::Domain_t::RandIter &amp;G, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#af12460cbc0f7735e5c6ac5eaba73a17b">More...</a><br /></td></tr>
<tr class="separator:af12460cbc0f7735e5c6ac5eaba73a17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2bcea333b6c2732fde289f3c572c00"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:a8c2bcea333b6c2732fde289f3c572c00"><td class="memTemplItemLeft" align="right" valign="top">PolRing::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8c2bcea333b6c2732fde289f3c572c00">CharPoly</a> (const PolRing &amp;R, typename PolRing::Element &amp;charp, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, const FFPACK_CHARPOLY_TAG CharpTag=FfpackAuto, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="memdesc:a8c2bcea333b6c2732fde289f3c572c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the characteristic polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a8c2bcea333b6c2732fde289f3c572c00">More...</a><br /></td></tr>
<tr class="separator:a8c2bcea333b6c2732fde289f3c572c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b163512f205e2336b48592d7463ead7"><td class="memTemplParams" colspan="2">template&lt;class PolRing &gt; </td></tr>
<tr class="memitem:a2b163512f205e2336b48592d7463ead7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ffpack_8h.html#a2b163512f205e2336b48592d7463ead7">RandomKrylovPrecond</a> (const PolRing &amp;PR, std::list&lt; typename PolRing::Element &gt; &amp;completedFactors, const size_t N, typename PolRing::Domain_t::Element_ptr A, const size_t lda, size_t &amp;Nb, typename PolRing::Domain_t::Element_ptr &amp;B, size_t &amp;ldb, typename PolRing::Domain_t::RandIter &amp;g, const size_t degree=__FFLASFFPACK_ARITHPROG_THRESHOLD)</td></tr>
<tr class="separator:a2b163512f205e2336b48592d7463ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225ba4356fcea2d470835ead0278237e"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial &gt; </td></tr>
<tr class="memitem:a225ba4356fcea2d470835ead0278237e"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a225ba4356fcea2d470835ead0278237e">MinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:a225ba4356fcea2d470835ead0278237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a225ba4356fcea2d470835ead0278237e">More...</a><br /></td></tr>
<tr class="separator:a225ba4356fcea2d470835ead0278237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial , class RandIter &gt; </td></tr>
<tr class="memitem:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a862701a92e6d2b12e40b5a7f6b2e06ee">MinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, RandIter &amp;G)</td></tr>
<tr class="memdesc:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a862701a92e6d2b12e40b5a7f6b2e06ee">More...</a><br /></td></tr>
<tr class="separator:a862701a92e6d2b12e40b5a7f6b2e06ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memTemplParams" colspan="2">template&lt;class Field , class Polynomial &gt; </td></tr>
<tr class="memitem:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memTemplItemLeft" align="right" valign="top">Polynomial &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac1eeaee05c99ce77fa38b64e8fe1fa11">MatVecMinPoly</a> (const Field &amp;F, Polynomial &amp;minP, const size_t N, typename Field::ConstElement_ptr A, const size_t lda, typename Field::ConstElement_ptr v, const size_t incv)</td></tr>
<tr class="memdesc:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimal polynomial of the matrix A and a vector v, namely the first linear dependency relation in the Krylov basis <img class="formulaInl" alt="$(v,Av, ..., A^Nv)$" src="form_91.png"/>.  <a href="namespace_f_f_p_a_c_k.html#ac1eeaee05c99ce77fa38b64e8fe1fa11">More...</a><br /></td></tr>
<tr class="separator:ac1eeaee05c99ce77fa38b64e8fe1fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb286015f6161e817d28298ac7f02e7e"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:afb286015f6161e817d28298ac7f02e7e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#afb286015f6161e817d28298ac7f02e7e">Rank</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:afb286015f6161e817d28298ac7f02e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rank of the given matrix using a PLUQ factorization.  <a href="namespace_f_f_p_a_c_k.html#afb286015f6161e817d28298ac7f02e7e">More...</a><br /></td></tr>
<tr class="separator:afb286015f6161e817d28298ac7f02e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231910d94ef4832edb786ceb8574cace"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a231910d94ef4832edb786ceb8574cace"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a231910d94ef4832edb786ceb8574cace">IsSingular</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:a231910d94ef4832edb786ceb8574cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given matrix is singular.  <a href="namespace_f_f_p_a_c_k.html#a231910d94ef4832edb786ceb8574cace">More...</a><br /></td></tr>
<tr class="separator:a231910d94ef4832edb786ceb8574cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memTemplItemLeft" align="right" valign="top">Field::Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a82f1c3a47ce5b9ee39c5ac44864add93">Det</a> (const Field &amp;F, typename Field::Element &amp;det, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P=NULL, size_t *Q=NULL)</td></tr>
<tr class="memdesc:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the given square matrix.  <a href="namespace_f_f_p_a_c_k.html#a82f1c3a47ce5b9ee39c5ac44864add93">More...</a><br /></td></tr>
<tr class="separator:a82f1c3a47ce5b9ee39c5ac44864add93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b24993d207d33830edf3286f7332631"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a8b24993d207d33830edf3286f7332631"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a8b24993d207d33830edf3286f7332631">Solve</a> (const Field &amp;F, const size_t M, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr x, const int incx, typename Field::ConstElement_ptr b, const int incb)</td></tr>
<tr class="memdesc:a8b24993d207d33830edf3286f7332631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear system AX = b using PLUQ factorization.  <a href="namespace_f_f_p_a_c_k.html#a8b24993d207d33830edf3286f7332631">More...</a><br /></td></tr>
<tr class="separator:a8b24993d207d33830edf3286f7332631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memTemplItemLeft" align="right" valign="top">*void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4f559150c4ef2579bbd9dcd0b97eef30">RandomNullSpaceVector</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr X, const size_t incX)</td></tr>
<tr class="memdesc:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve L X = B or X L = B in place.  <a href="namespace_f_f_p_a_c_k.html#a4f559150c4ef2579bbd9dcd0b97eef30">More...</a><br /></td></tr>
<tr class="separator:a4f559150c4ef2579bbd9dcd0b97eef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a668c07f738a5d813fc1ff7d0b60cd4ef">NullSpaceBasis</a> (const Field &amp;F, const FFLAS::FFLAS_SIDE Side, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;NS, size_t &amp;ldn, size_t &amp;NSdim)</td></tr>
<tr class="memdesc:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a basis of the Left/Right nullspace of the matrix A.  <a href="namespace_f_f_p_a_c_k.html#a668c07f738a5d813fc1ff7d0b60cd4ef">More...</a><br /></td></tr>
<tr class="separator:a668c07f738a5d813fc1ff7d0b60cd4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a61b01710a3a14e5ddeff63e7dde312e5">RowRankProfile</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rkprofile, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:a61b01710a3a14e5ddeff63e7dde312e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#a61b01710a3a14e5ddeff63e7dde312e5">More...</a><br /></td></tr>
<tr class="separator:a61b01710a3a14e5ddeff63e7dde312e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad2a30cbb378686c18f8fda52a2ea692c">ColumnRankProfile</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rkprofile, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ad2a30cbb378686c18f8fda52a2ea692c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the column rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#ad2a30cbb378686c18f8fda52a2ea692c">More...</a><br /></td></tr>
<tr class="separator:ad2a30cbb378686c18f8fda52a2ea692c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210f3ceeca532699f4567098c22e0c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a210f3ceeca532699f4567098c22e0c30">RankProfileFromLU</a> (const size_t *P, const size_t N, const size_t R, size_t *rkprofile, const FFPACK_LU_TAG LuTag)</td></tr>
<tr class="memdesc:a210f3ceeca532699f4567098c22e0c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the column/row rank profile from the permutation of an LU decomposition.  <a href="namespace_f_f_p_a_c_k.html#a210f3ceeca532699f4567098c22e0c30">More...</a><br /></td></tr>
<tr class="separator:a210f3ceeca532699f4567098c22e0c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6732312bd3b9111ed2beda4d4989407"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab6732312bd3b9111ed2beda4d4989407">LeadingSubmatrixRankProfiles</a> (const size_t M, const size_t N, const size_t R, const size_t LSm, const size_t LSn, const size_t *P, const size_t *Q, size_t *RRP, size_t *CRP)</td></tr>
<tr class="memdesc:ab6732312bd3b9111ed2beda4d4989407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the row and column rank profiles of any leading submatrix from the PLUQ decomposition.  <a href="namespace_f_f_p_a_c_k.html#ab6732312bd3b9111ed2beda4d4989407">More...</a><br /></td></tr>
<tr class="separator:ab6732312bd3b9111ed2beda4d4989407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a9101aa5d87ae4ffcacf3f5ea97fdd4df">RowRankProfileSubmatrixIndices</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rowindices, size_t *&amp;colindices, size_t &amp;R)</td></tr>
<tr class="memdesc:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">RowRankProfileSubmatrixIndices.  <a href="namespace_f_f_p_a_c_k.html#a9101aa5d87ae4ffcacf3f5ea97fdd4df">More...</a><br /></td></tr>
<tr class="separator:a9101aa5d87ae4ffcacf3f5ea97fdd4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a8f20a642f161be15d54e9e84a276f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ad6a8f20a642f161be15d54e9e84a276f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ad6a8f20a642f161be15d54e9e84a276f">ColRankProfileSubmatrixIndices</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *&amp;rowindices, size_t *&amp;colindices, size_t &amp;R)</td></tr>
<tr class="memdesc:ad6a8f20a642f161be15d54e9e84a276f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the indices of the submatrix r*r X of A whose columns correspond to the column rank profile of A.  <a href="namespace_f_f_p_a_c_k.html#ad6a8f20a642f161be15d54e9e84a276f">More...</a><br /></td></tr>
<tr class="separator:ad6a8f20a642f161be15d54e9e84a276f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae44ada9ac14df2273cd42d5844b4fa4a">RowRankProfileSubmatrix</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;X, size_t &amp;R)</td></tr>
<tr class="memdesc:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the r*r submatrix X of A, by picking the row rank profile rows of A.  <a href="namespace_f_f_p_a_c_k.html#ae44ada9ac14df2273cd42d5844b4fa4a">More...</a><br /></td></tr>
<tr class="separator:ae44ada9ac14df2273cd42d5844b4fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8a8befa801a6defffa9043081cb60"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aa6a8a8befa801a6defffa9043081cb60"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aa6a8a8befa801a6defffa9043081cb60">ColRankProfileSubmatrix</a> (const Field &amp;F, const size_t M, const size_t N, typename Field::Element_ptr A, const size_t lda, typename Field::Element_ptr &amp;X, size_t &amp;R)</td></tr>
<tr class="memdesc:aa6a8a8befa801a6defffa9043081cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <img class="formulaInl" alt="$ r\times r$" src="form_93.png"/> submatrix X of A, by picking the row rank profile rows of A.  <a href="namespace_f_f_p_a_c_k.html#aa6a8a8befa801a6defffa9043081cb60">More...</a><br /></td></tr>
<tr class="separator:aa6a8a8befa801a6defffa9043081cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00545c213322e599f00bfa88dda0b201"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a00545c213322e599f00bfa88dda0b201"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a00545c213322e599f00bfa88dda0b201">getTriangular</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false)</td></tr>
<tr class="memdesc:a00545c213322e599f00bfa88dda0b201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a triangular matrix from a compact storage A=L\U of rank R.  <a href="namespace_f_f_p_a_c_k.html#a00545c213322e599f00bfa88dda0b201">More...</a><br /></td></tr>
<tr class="separator:a00545c213322e599f00bfa88dda0b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9639c015458dc8849bc463bbcb1da1f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab9639c015458dc8849bc463bbcb1da1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab9639c015458dc8849bc463bbcb1da1f">getTriangular</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, typename Field::Element_ptr A, const size_t lda)</td></tr>
<tr class="memdesc:ab9639c015458dc8849bc463bbcb1da1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U to reveal a triangular matrix of rank R.  <a href="namespace_f_f_p_a_c_k.html#ab9639c015458dc8849bc463bbcb1da1f">More...</a><br /></td></tr>
<tr class="separator:ab9639c015458dc8849bc463bbcb1da1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef728bf19985baf2a219feac8cb28929"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aef728bf19985baf2a219feac8cb28929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aef728bf19985baf2a219feac8cb28929">getEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aef728bf19985baf2a219feac8cb28929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#aef728bf19985baf2a219feac8cb28929">More...</a><br /></td></tr>
<tr class="separator:aef728bf19985baf2a219feac8cb28929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae248d48e7687959fa602ea13fdb8bf4a">getEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::Element_ptr A, const size_t lda, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ae248d48e7687959fa602ea13fdb8bf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U obtained by RowEchelonForm or ColumnEchelonForm to reveal an echelon form of rank R.  <a href="namespace_f_f_p_a_c_k.html#ae248d48e7687959fa602ea13fdb8bf4a">More...</a><br /></td></tr>
<tr class="separator:ae248d48e7687959fa602ea13fdb8bf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee39112d215c8f520c8a8409dfcb82b5"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:aee39112d215c8f520c8a8409dfcb82b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#aee39112d215c8f520c8a8409dfcb82b5">getEchelonTransform</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t M, const size_t N, const size_t R, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:aee39112d215c8f520c8a8409dfcb82b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#aee39112d215c8f520c8a8409dfcb82b5">More...</a><br /></td></tr>
<tr class="separator:aee39112d215c8f520c8a8409dfcb82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae330c736c7e0c7eb585d7885bd70004b"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae330c736c7e0c7eb585d7885bd70004b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae330c736c7e0c7eb585d7885bd70004b">getReducedEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const bool OnlyNonZeroVectors=false, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ae330c736c7e0c7eb585d7885bd70004b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a matrix in echelon form from a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true.  <a href="namespace_f_f_p_a_c_k.html#ae330c736c7e0c7eb585d7885bd70004b">More...</a><br /></td></tr>
<tr class="separator:ae330c736c7e0c7eb585d7885bd70004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ab82ac3be0b0c94ca64f73e84952e9466">getReducedEchelonForm</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, typename Field::Element_ptr A, const size_t lda, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:ab82ac3be0b0c94ca64f73e84952e9466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a compact storage A=L\U of rank R obtained by ReducedRowEchelonForm or ReducedColumnEchelonForm with transform = true.  <a href="namespace_f_f_p_a_c_k.html#ab82ac3be0b0c94ca64f73e84952e9466">More...</a><br /></td></tr>
<tr class="separator:ab82ac3be0b0c94ca64f73e84952e9466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e646e2d8b711a662e010c74ad57b82"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:af4e646e2d8b711a662e010c74ad57b82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#af4e646e2d8b711a662e010c74ad57b82">getReducedEchelonTransform</a> (const Field &amp;F, const FFLAS::FFLAS_UPLO Uplo, const size_t M, const size_t N, const size_t R, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt, const FFPACK_LU_TAG LuTag=FfpackSlabRecursive)</td></tr>
<tr class="memdesc:af4e646e2d8b711a662e010c74ad57b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a transformation matrix to echelon form from a compact storage A=L\U of rank R obtained by RowEchelonForm or ColumnEchelonForm.  <a href="namespace_f_f_p_a_c_k.html#af4e646e2d8b711a662e010c74ad57b82">More...</a><br /></td></tr>
<tr class="separator:af4e646e2d8b711a662e010c74ad57b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b938a39392432499087789fd3582eac"><td class="memItemLeft" align="right" valign="top"><a id="a7b938a39392432499087789fd3582eac" name="a7b938a39392432499087789fd3582eac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PLUQtoEchelonPermutation</b> (const size_t N, const size_t R, const size_t *P, size_t *outPerm)</td></tr>
<tr class="memdesc:a7b938a39392432499087789fd3582eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary routine: determines the permutation that changes a PLUQ decomposition into a echelon form revealing PLUQ decomposition. <br /></td></tr>
<tr class="separator:a7b938a39392432499087789fd3582eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3229b60de912473f3ce4cb3df8753e"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a9c3229b60de912473f3ce4cb3df8753e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a9c3229b60de912473f3ce4cb3df8753e">LTBruhatGen</a> (const Field &amp;Fi, const FFLAS::FFLAS_DIAG diag, const size_t N, typename Field::Element_ptr A, const size_t lda, size_t *P, size_t *Q)</td></tr>
<tr class="memdesc:a9c3229b60de912473f3ce4cb3df8753e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LTBruhatGen Suppose A is Left Triangular Matrix This procedure computes the Bruhat Representation of A and return the rank of A.  <a href="namespace_f_f_p_a_c_k.html#a9c3229b60de912473f3ce4cb3df8753e">More...</a><br /></td></tr>
<tr class="separator:a9c3229b60de912473f3ce4cb3df8753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ae9d34e03d5e3d7d413acd1947a821a7f">getLTBruhatGen</a> (const Field &amp;Fi, const size_t N, const size_t r, const size_t *P, const size_t *Q, typename Field::Element_ptr R, const size_t ldr)</td></tr>
<tr class="memdesc:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetLTBruhatGen This procedure Computes the Rank Revealing Matrix based on the Bruhta representation of a Matrix.  <a href="namespace_f_f_p_a_c_k.html#ae9d34e03d5e3d7d413acd1947a821a7f">More...</a><br /></td></tr>
<tr class="separator:ae9d34e03d5e3d7d413acd1947a821a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4970621f589c8a8c0e26dbb8a61d386f">getLTBruhatGen</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, const FFLAS::FFLAS_DIAG diag, const size_t N, const size_t r, const size_t *P, const size_t *Q, typename Field::ConstElement_ptr A, const size_t lda, typename Field::Element_ptr T, const size_t ldt)</td></tr>
<tr class="memdesc:a4970621f589c8a8c0e26dbb8a61d386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetLTBruhatGen This procedure computes the matrix L or U f the Bruhat Representation Suppose that A is the bruhat representation of a matrix.  <a href="namespace_f_f_p_a_c_k.html#a4970621f589c8a8c0e26dbb8a61d386f">More...</a><br /></td></tr>
<tr class="separator:a4970621f589c8a8c0e26dbb8a61d386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39434278672787e41dff88fc5977d8b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a39434278672787e41dff88fc5977d8b6">LTQSorder</a> (const size_t N, const size_t r, const size_t *P, const size_t *Q)</td></tr>
<tr class="memdesc:a39434278672787e41dff88fc5977d8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LTQSorder This procedure computes the order of quasiseparability of a matrix.  <a href="namespace_f_f_p_a_c_k.html#a39434278672787e41dff88fc5977d8b6">More...</a><br /></td></tr>
<tr class="separator:a39434278672787e41dff88fc5977d8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#ac4c6629de5a1a0349eac3c1d2b73f1a1">CompressToBlockBiDiagonal</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, size_t N, size_t s, size_t r, const size_t *P, const size_t *Q, typename Field::Element_ptr A, size_t lda, typename Field::Element_ptr X, size_t ldx, size_t *K, size_t *M, size_t *T)</td></tr>
<tr class="memdesc:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CompressToBlockBiDiagonal This procedure compress a compact representation of a row echelon form or column echelon form.  <a href="namespace_f_f_p_a_c_k.html#ac4c6629de5a1a0349eac3c1d2b73f1a1">More...</a><br /></td></tr>
<tr class="separator:ac4c6629de5a1a0349eac3c1d2b73f1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4354fca8409da50f288d59c69a888970"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a4354fca8409da50f288d59c69a888970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a4354fca8409da50f288d59c69a888970">ExpandBlockBiDiagonalToBruhat</a> (const Field &amp;Fi, const FFLAS::FFLAS_UPLO Uplo, size_t N, size_t s, size_t r, typename Field::Element_ptr A, size_t lda, typename Field::Element_ptr X, size_t ldx, size_t NbBlocks, size_t *K, size_t *M, size_t *T)</td></tr>
<tr class="memdesc:a4354fca8409da50f288d59c69a888970"><td class="mdescLeft">&#160;</td><td class="mdescRight">ExpandBlockBiDiagonal This procedure expand a compact representation of a row echelon form or column echelon form.  <a href="namespace_f_f_p_a_c_k.html#a4354fca8409da50f288d59c69a888970">More...</a><br /></td></tr>
<tr class="separator:a4354fca8409da50f288d59c69a888970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a1508bd2e3ea0ef3b4e9022783dc871e7">Bruhat2EchelonPermutation</a> (size_t N, size_t R, const size_t *P, const size_t *Q, size_t *M)</td></tr>
<tr class="memdesc:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bruhat2EchelonPermutation (N,R,P,Q) Compute M such that LM or MU is in echelon form where L or U are factors of the Bruhat Rpresentation.  <a href="namespace_f_f_p_a_c_k.html#a1508bd2e3ea0ef3b4e9022783dc871e7">More...</a><br /></td></tr>
<tr class="separator:a1508bd2e3ea0ef3b4e9022783dc871e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memTemplParams" colspan="2"><a id="af40ef0a04be6f8fa4d423a1d49094b07" name="af40ef0a04be6f8fa4d423a1d49094b07"></a>
template&lt;class Field &gt; </td></tr>
<tr class="memitem:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>productBruhatxTS</b> (const Field &amp;Fi, size_t N, size_t s, size_t r, const size_t *P, const size_t *Q, const typename Field::Element_ptr Xu, size_t ldu, size_t NbBlocksU, size_t *Ku, size_t *Tu, size_t *MU, const typename Field::Element_ptr Xl, size_t ldl, size_t NbBlocksL, size_t *Kl, size_t *Tl, size_t *ML, typename Field::Element_ptr B, size_t t, size_t ldb, typename Field::Element_ptr C, size_t ldc)</td></tr>
<tr class="memdesc:af40ef0a04be6f8fa4d423a1d49094b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">productBruhatxTS Comput the product between the CRE compact representation of a matrix A and B a tall matrix <br /></td></tr>
<tr class="separator:af40ef0a04be6f8fa4d423a1d49094b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fb5610440268a1977b4b3a2adcfc8"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a691fb5610440268a1977b4b3a2adcfc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a691fb5610440268a1977b4b3a2adcfc8">productSSSxTS</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::ConstElement_ptr P, size_t ldp, typename Field::ConstElement_ptr Q, size_t ldq, typename Field::ConstElement_ptr R, size_t ldr, typename Field::ConstElement_ptr U, size_t ldu, typename Field::ConstElement_ptr V, size_t ldv, typename Field::ConstElement_ptr W, size_t ldw, typename Field::ConstElement_ptr D, size_t ldd, size_t t, const typename Field::Element alpha, typename Field::Element_ptr B, size_t ldb, const typename Field::Element beta, typename Field::Element_ptr C, size_t ldc)</td></tr>
<tr class="memdesc:a691fb5610440268a1977b4b3a2adcfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of a quasi-separable matrix A, represented by a sequentially semi-separable generator, with a dense rectangular matrix B: <img class="formulaInl" alt="$ C \gets \alpha * A \times B + beta C $" src="form_94.png"/>.  <a href="namespace_f_f_p_a_c_k.html#a691fb5610440268a1977b4b3a2adcfc8">More...</a><br /></td></tr>
<tr class="separator:a691fb5610440268a1977b4b3a2adcfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cbfc65f210580e0ef820d42774a046"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a75cbfc65f210580e0ef820d42774a046"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a75cbfc65f210580e0ef820d42774a046">SSSToDense</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::ConstElement_ptr P, size_t ldp, typename Field::ConstElement_ptr Q, size_t ldq, typename Field::ConstElement_ptr R, size_t ldr, typename Field::ConstElement_ptr U, size_t ldu, typename Field::ConstElement_ptr V, size_t ldv, typename Field::ConstElement_ptr W, size_t ldw, typename Field::ConstElement_ptr D, size_t ldd, typename Field::Element_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a75cbfc65f210580e0ef820d42774a046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a quasi-separable matrix A from its SSS generators.  <a href="namespace_f_f_p_a_c_k.html#a75cbfc65f210580e0ef820d42774a046">More...</a><br /></td></tr>
<tr class="separator:a75cbfc65f210580e0ef820d42774a046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad974b5a7591c6956046d4473a30dc"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a43ad974b5a7591c6956046d4473a30dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a43ad974b5a7591c6956046d4473a30dc">DenseToSSS</a> (const Field &amp;Fi, size_t N, size_t s, typename Field::Element_ptr P, size_t ldp, typename Field::Element_ptr Q, size_t ldq, typename Field::Element_ptr R, size_t ldr, typename Field::Element_ptr U, size_t ldu, typename Field::Element_ptr V, size_t ldv, typename Field::Element_ptr W, size_t ldw, typename Field::Element_ptr D, size_t ldd, typename Field::ConstElement_ptr A, size_t lda)</td></tr>
<tr class="memdesc:a43ad974b5a7591c6956046d4473a30dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SSS generators for a quasi-separable matrix A.  <a href="namespace_f_f_p_a_c_k.html#a43ad974b5a7591c6956046d4473a30dc">More...</a><br /></td></tr>
<tr class="separator:a43ad974b5a7591c6956046d4473a30dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memTemplParams" colspan="2">template&lt;class Field &gt; </td></tr>
<tr class="memitem:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memTemplItemLeft" align="right" valign="top">Field::Element_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_f_p_a_c_k.html#a3cd7b5a41ec8f1e7b722b50e8a836559">LQUPtoInverseOfFullRankMinor</a> (const Field &amp;F, const size_t rank, typename Field::Element_ptr A_factors, const size_t lda, const size_t *QtPointer, typename Field::Element_ptr X, const size_t ldx)</td></tr>
<tr class="memdesc:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="mdescLeft">&#160;</td><td class="mdescRight">LQUPtoInverseOfFullRankMinor.  <a href="namespace_f_f_p_a_c_k.html#a3cd7b5a41ec8f1e7b722b50e8a836559">More...</a><br /></td></tr>
<tr class="separator:a3cd7b5a41ec8f1e7b722b50e8a836559"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Set of elimination based routines for dense linear algebra. </p>
<p >Matrices are supposed over finite prime field of characteristic less than 2^26. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8cf910bfffdd3f3f71bff7b29ae238e6" name="a8cf910bfffdd3f3f71bff7b29ae238e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf910bfffdd3f3f71bff7b29ae238e6">&#9670;&nbsp;</a></span>GaussJordan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GaussJordan </td>
          <td>(</td>
          <td class="paramtype">const Field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Field::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>colbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>rowbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>colsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FFPACK::FFPACK_LU_TAG&#160;</td>
          <td class="paramname"><em>LuTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gauss-Jordan algorithm computing the Reduced Row echelon form and its transform matrix. </p>
<dl class="bib"><dt><b><a class="el" href="bib.html#_bib000009">Bibliography:</a></b></dt><dd><ul>
<li>Algorithm 2.8 of A. Storjohann Thesis 2000,</li>
<li>Algorithm 11 of Jeannerod C-P., Pernet, C. and Storjohann, A. <em><code>Rank-profile</code> revealing Gaussian elimination and the CUP matrix decomposition </em>, J. of Symbolic Comp., 2013 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>row dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>column dimension of A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>an m x n matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lda</td><td>leading dimension of A </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">P</td><td>row permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Q</td><td>column permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">LuTag</td><td>set the base case to a Tile (FfpackGaussJordanTile) or Slab (FfpackGaussJordanSlab) recursive RedEchelon </td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> | I | A11 | A12 | | |-&mdash;|--&mdash;|--&mdash;|-&mdash;| | |I | *| A22 | | | |0 | 0| A22 | | |-&mdash;|--&mdash;|--&mdash;|-&mdash;| | | 0 | A32 | | |-&mdash;|--&mdash;|--&mdash;|-&mdash;|</p>
<p >where the transformation matrix is stored at the pivot column position</p>

</div>
</div>
<a id="a2b163512f205e2336b48592d7463ead7" name="a2b163512f205e2336b48592d7463ead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b163512f205e2336b48592d7463ead7">&#9670;&nbsp;</a></span>RandomKrylovPrecond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RandomKrylovPrecond </td>
          <td>(</td>
          <td class="paramtype">const PolRing &amp;&#160;</td>
          <td class="paramname"><em>PR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; typename PolRing::Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>completedFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::Element_ptr&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::Element_ptr &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PolRing::Domain_t::RandIter &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em> = <code>__FFLASFFPACK_ARITHPROG_THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>swap to save space ?? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>don't assing K2 c*noc x N but only mas (c,noc) x N and store each one after the other <br  />
 </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>swap to save space ?? </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>don't assing K2 c*noc x N but only mas (c,noc) x N and store each one after the other <br  />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 3 2025 16:14:32 for FFLAS-FFPACK by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
